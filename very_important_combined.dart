// COMBINED FILE - GENERATED BY df_combinator v0.1.0
//
// --- FIX LOG ---
// 1. Removed duplicate `main` functions.
// 2. De-duplicated helper functions.
// 3. Resolved `Colors` name conflict with `vec` prefix.
// 4. Added `dispose()` overrides to all page states to cancel Tickers.
// 5. Added OpenWorldPage demo.
// 6. CORRECTED vector_math import to use the 32-bit version (vector_math.dart) to match flutter_gpu's expectation.
// Generated on: 2025-07-20 00:07:47.569362Z UTC

// --- Consolidated Imports ---
import 'dart:collection'; // Needed for Queue
import 'dart:math';
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart'; // FIX: Added for keyboard input
import 'package:flutter_gpu/gpu.dart' as gpu;
// CORRECTED: Use the 32-bit vector math library to match flutter_gpu's internal types.
import 'package:vector_math/vector_math.dart' as vec;
// --- End of Imports ---

// --- De-duplicated Helper Functions ---
ByteData float32(List<double> values) {
  return Float32List.fromList(values).buffer.asByteData();
}

ByteData float32Mat(vec.Matrix4 matrix) {
  return Float32List.fromList(matrix.storage).buffer.asByteData();
}

ByteData uint16(List<int> values) {
  return Uint16List.fromList(values).buffer.asByteData();
}

ByteData uint32(List<int> values) {
  return Uint32List.fromList(values).buffer.asByteData();
}
// --- End of Helper Functions ---

// --------------------------------------------------
// Source: .\lib\shaders.dart
// --------------------------------------------------
const String _kShaderBundlePath = 'build/shaderbundles/TestLibrary.shaderbundle';
gpu.ShaderLibrary? _shaderLibrary;
gpu.ShaderLibrary get shaderLibrary {
  if (_shaderLibrary != null) return _shaderLibrary!;
  _shaderLibrary = gpu.ShaderLibrary.fromAsset(_kShaderBundlePath);
  if (_shaderLibrary != null) return _shaderLibrary!;
  throw Exception("Failed to load shader bundle! ($_kShaderBundlePath)");
}

/*// --------------------------------------------------
// Source: lib\open_world_demo.dart (NEW FILE)
// --------------------------------------------------

class OpenWorldPage extends StatefulWidget {
  const OpenWorldPage({super.key});

  @override
  State<OpenWorldPage> createState() => _OpenWorldPageState();
}

class _OpenWorldPageState extends State<OpenWorldPage> {
  // Camera state
  double _cameraOrbitX = 0.0;
  double _cameraOrbitY = 0.5; // Start looking down slightly
  double _cameraDistance = 5.0;

  void _onPanUpdate(DragUpdateDetails details) {
    setState(() {
      _cameraOrbitX += details.delta.dx * 0.01;
      _cameraOrbitY -= details.delta.dy * 0.01;
      // Clamp Y orbit to avoid flipping the camera
      _cameraOrbitY = _cameraOrbitY.clamp(0.1, pi - 0.1);
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        const Padding(
          padding: EdgeInsets.all(16.0),
          child: Text(
            'Drag to orbit the camera',
            style: TextStyle(fontSize: 18),
            textAlign: TextAlign.center,
          ),
        ),
        Expanded(
          child: LayoutBuilder(
            builder: (context, constraints) {
              return GestureDetector(
                onPanUpdate: _onPanUpdate,
                child: CustomPaint(
                  size: Size(constraints.maxWidth, constraints.maxHeight),
                  painter: ScenePainter(
                    cameraOrbitX: _cameraOrbitX,
                    cameraOrbitY: _cameraOrbitY,
                    cameraDistance: _cameraDistance,
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}

class ScenePainter extends CustomPainter {
  ScenePainter({
    required this.cameraOrbitX,
    required this.cameraOrbitY,
    required this.cameraDistance,
  });

  final double cameraOrbitX;
  final double cameraOrbitY;
  final double cameraDistance;

  @override
  void paint(Canvas canvas, Size size) {
    final gpu.Texture? renderTexture = gpu.gpuContext.createTexture(
        gpu.StorageMode.devicePrivate, size.width.toInt(), size.height.toInt(),
        enableRenderTargetUsage: true,
        enableShaderReadUsage: true,
        coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (renderTexture == null) return;

    final gpu.Texture? depthTexture = gpu.gpuContext.createTexture(
        gpu.StorageMode.deviceTransient,
        size.width.toInt(),
        size.height.toInt(),
        format: gpu.gpuContext.defaultDepthStencilFormat,
        enableRenderTargetUsage: true,
        coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (depthTexture == null) return;

    final commandBuffer = gpu.gpuContext.createCommandBuffer();
    final renderTarget = gpu.RenderTarget.singleColor(
      gpu.ColorAttachment(
          texture: renderTexture,
          clearValue: vec.Vector4(0.0627, 0.0627, 0.0627, 1.0)),
      depthStencilAttachment: gpu.DepthStencilAttachment(
          texture: depthTexture, depthClearValue: 1.0),
    );
    final pass = commandBuffer.createRenderPass(renderTarget);
    pass.setDepthWriteEnable(true);
    pass.setDepthCompareOperation(gpu.CompareFunction.less);

    final vertex = shaderLibrary['SceneVertex']!;
    final fragment = shaderLibrary['SceneFragment']!;
    final pipeline = gpu.gpuContext.createRenderPipeline(vertex, fragment);
    pass.bindPipeline(pipeline);

    final cameraPosition = vec.Vector3(
      cameraDistance * sin(cameraOrbitX) * sin(cameraOrbitY),
      cameraDistance * cos(cameraOrbitY),
      cameraDistance * cos(cameraOrbitX) * sin(cameraOrbitY),
    );
    final viewMatrix = vec.makeViewMatrix(cameraPosition, vec.Vector3(0, 0, 0), vec.Vector3(0, 1, 0));
    final projectionMatrix = vec.makePerspectiveMatrix(pi / 4, size.width / size.height, 0.1, 100.0);
    final viewProjectionMatrix = projectionMatrix * viewMatrix;

    final lightInfoSlot = fragment.getUniformSlot('LightInfo');
    final lightInfoData = Float32List.fromList([
      -1.0, -1.0, -0.5, 0.0,
      1.0, 1.0, 1.0, 1.0,
      0.1, 0.1, 0.1, 1.0,
    ]);
    final lightInfoBuffer = gpu.gpuContext.createHostBuffer().emplace(lightInfoData.buffer.asByteData());
    pass.bindUniform(lightInfoSlot, lightInfoBuffer);

    final sceneInfoSlot = vertex.getUniformSlot('SceneInfo');
    _drawPlane(pass, viewProjectionMatrix, sceneInfoSlot);
    _drawCube(pass, viewProjectionMatrix, sceneInfoSlot);

    commandBuffer.submit();
    final image = renderTexture.asImage();
    canvas.drawImage(image, Offset.zero, Paint());
  }

  void _drawPlane(gpu.RenderPass pass, vec.Matrix4 vpMatrix, gpu.UniformSlot sceneInfoSlot) {
    final transients = gpu.gpuContext.createHostBuffer();
    final vertices = transients.emplace(float32(<double>[
      -10, -1, -10,      0, 1, 0,
       10, -1, -10,      0, 1, 0,
       10, -1,  10,      0, 1, 0,
      -10, -1,  10,      0, 1, 0,
    ]));
    final indices = transients.emplace(uint16(<int>[0, 1, 2, 0, 2, 3]));
    pass.bindVertexBuffer(vertices, 4);
    pass.bindIndexBuffer(indices, gpu.IndexType.int16, 6);

    final modelMatrix = vec.Matrix4.identity();
    final mvp = vpMatrix * modelMatrix;
    
    final sceneInfoData = Float32List.fromList([...mvp.storage, ...modelMatrix.storage]);
    final sceneInfoBuffer = transients.emplace(sceneInfoData.buffer.asByteData());
    pass.bindUniform(sceneInfoSlot, sceneInfoBuffer);
    pass.draw();
  }

  void _drawCube(gpu.RenderPass pass, vec.Matrix4 vpMatrix, gpu.UniformSlot sceneInfoSlot) {
    final transients = gpu.gpuContext.createHostBuffer();
    final vertices = transients.emplace(float32(<double>[
      -1,-1,-1, -1,0,0,  -1,-1,1, -1,0,0,  -1,1,1, -1,0,0,  -1,1,-1, -1,0,0,
      1,-1,-1, 1,0,0,  1,1,-1, 1,0,0,  1,1,1, 1,0,0,  1,-1,1, 1,0,0,
      -1,-1,-1, 0,-1,0,  1,-1,-1, 0,-1,0,  1,-1,1, 0,-1,0,  -1,-1,1, 0,-1,0,
      -1,1,-1, 0,1,0,  -1,1,1, 0,1,0,  1,1,1, 0,1,0,  1,1,-1, 0,1,0,
      -1,-1,-1, 0,0,-1,  -1,1,-1, 0,0,-1,  1,1,-1, 0,0,-1,  1,-1,-1, 0,0,-1,
      -1,-1,1, 0,0,1,  1,-1,1, 0,0,1,  1,1,1, 0,0,1,  -1,1,1, 0,0,1,
    ]));
    final indices = transients.emplace(uint16(<int>[
      0,1,2, 0,2,3,  4,5,6, 4,6,7,  8,9,10, 8,10,11,
      12,13,14, 12,14,15,  16,17,18, 16,18,19,  20,21,22, 20,22,23
    ]));
    pass.bindVertexBuffer(vertices, 24);
    pass.bindIndexBuffer(indices, gpu.IndexType.int16, 36);

    final modelMatrix = vec.Matrix4.identity();
    final mvp = vpMatrix * modelMatrix;
    
    final sceneInfoData = Float32List.fromList([...mvp.storage, ...modelMatrix.storage]);
    final sceneInfoBuffer = transients.emplace(sceneInfoData.buffer.asByteData());
    pass.bindUniform(sceneInfoSlot, sceneInfoBuffer);
    pass.draw();
  }

  @override
  bool shouldRepaint(covariant ScenePainter oldDelegate) {
    return oldDelegate.cameraOrbitX != cameraOrbitX ||
        oldDelegate.cameraOrbitY != cameraOrbitY ||
        oldDelegate.cameraDistance != cameraDistance;
  }
}*/

/*// --------------------------------------------------
// Source: lib\instanced_demo.dart (CORRECTED)
// --------------------------------------------------

class InstancedDemoPage extends StatefulWidget {
  const InstancedDemoPage({super.key});

  @override
  State<InstancedDemoPage> createState() => _InstancedDemoPageState();
}

class _InstancedDemoPageState extends State<InstancedDemoPage> {
  vec.Vector3 _cameraOrbit = vec.Vector3(0.8, 1.2, 0.0);
  double _cameraDistance = 15.0;
  vec.Vector3 _playerPosition = vec.Vector3.zero();
  final Set<LogicalKeyboardKey> _keysPressed = {};
  Ticker? _ticker;
  double _time = 0;
  final FocusNode _focusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    _ticker = Ticker((elapsed) {
      if (mounted) setState(() => _time = elapsed.inMilliseconds / 1000.0);
    });
    _ticker!.start();
  }

  @override
  void dispose() {
    _ticker?.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  void _handleKeyEvent(KeyEvent event) {
    setState(() {
      if (event is KeyDownEvent) {
        _keysPressed.add(event.logicalKey);
      } else if (event is KeyUpEvent) {
        _keysPressed.remove(event.logicalKey);
      }
    });
  }

  void _updatePlayerPosition() {
    const double moveSpeed = 0.1;
    final vec.Vector3 moveDirection = vec.Vector3.zero();
    if (_keysPressed.contains(LogicalKeyboardKey.keyW)) moveDirection.z -= moveSpeed;
    if (_keysPressed.contains(LogicalKeyboardKey.keyS)) moveDirection.z += moveSpeed;
    if (_keysPressed.contains(LogicalKeyboardKey.keyA)) moveDirection.x -= moveSpeed;
    if (_keysPressed.contains(LogicalKeyboardKey.keyD)) moveDirection.x += moveSpeed;
    _playerPosition += moveDirection;
  }

  @override
  Widget build(BuildContext context) {
    FocusScope.of(context).requestFocus(_focusNode);
    _updatePlayerPosition();

    return KeyboardListener(
      focusNode: _focusNode,
      onKeyEvent: _handleKeyEvent,
      child: GestureDetector(
        onPanUpdate: (details) {
          setState(() {
            _cameraOrbit.x += details.delta.dx * 0.01;
            _cameraOrbit.y -= details.delta.dy * 0.01;
            _cameraOrbit.y = _cameraOrbit.y.clamp(0.1, pi - 0.1);
          });
        },
        child: CustomPaint(
          size: Size.infinite,
          painter: InstancedScenePainter(
            cameraOrbit: _cameraOrbit,
            cameraDistance: _cameraDistance,
            playerPosition: _playerPosition,
            time: _time,
          ),
        ),
      ),
    );
  }
}

class InstancedScenePainter extends CustomPainter {
  InstancedScenePainter({
    required this.cameraOrbit,
    required this.cameraDistance,
    required this.playerPosition,
    required this.time,
  });

  final vec.Vector3 cameraOrbit;
  final double cameraDistance;
  final vec.Vector3 playerPosition;
  final double time;

  static gpu.DeviceBuffer? _cubeVertexBuffer;
  static gpu.DeviceBuffer? _cubeIndexBuffer;
  static gpu.DeviceBuffer? _instanceOffsetBuffer;
  static gpu.RenderPipeline? _instancedPipeline;
  static gpu.RenderPipeline? _playerPipeline;
  static int _instanceCount = 0;
  static const int _cubeIndexCount = 36;

  void _initializeGeometryAndPipeline() {
    if (_cubeVertexBuffer != null) return;

    final floatSize = 4;
    final stride = floatSize * 10;

    // FIX: Define the vertex layout for our instanced shader.
    final instancedVertexLayout = gpu.VertexLayout(
      attributes: [
        // Per-vertex attributes from buffer 0
        gpu.VertexAttribute(shaderLocation: 0, format: gpu.VertexFormat.float32x3, offset: 0, bufferSlot: 0, stepFunction: gpu.VertexStepFunction.perVertex), // Position
        gpu.VertexAttribute(shaderLocation: 1, format: gpu.VertexFormat.float32x3, offset: floatSize * 3, bufferSlot: 0, stepFunction: gpu.VertexStepFunction.perVertex), // Normal
        gpu.VertexAttribute(shaderLocation: 2, format: gpu.VertexFormat.float32x4, offset: floatSize * 6, bufferSlot: 0, stepFunction: gpu.VertexStepFunction.perVertex), // Color
        // Per-instance attribute from buffer 1
        gpu.VertexAttribute(shaderLocation: 3, format: gpu.VertexFormat.float32x3, offset: 0, bufferSlot: 1, stepFunction: gpu.VertexStepFunction.perInstance), // Instance Offset
      ],
      stride: stride,
    );
    _instancedPipeline = gpu.gpuContext.createRenderPipeline(
        shaderLibrary['InstancedSceneVertex']!, shaderLibrary['SceneFragment']!,
        vertexLayout: instancedVertexLayout);

    // FIX: Define the vertex layout for our standard player cube shader.
    final standardVertexLayout = gpu.VertexLayout(
      attributes: [
        gpu.VertexAttribute(shaderLocation: 0, format: gpu.VertexFormat.float32x3, offset: 0),
        gpu.VertexAttribute(shaderLocation: 1, format: gpu.VertexFormat.float32x3, offset: floatSize * 3),
        gpu.VertexAttribute(shaderLocation: 2, format: gpu.VertexFormat.float32x4, offset: floatSize * 6),
      ],
      stride: stride,
    );
    _playerPipeline = gpu.gpuContext.createRenderPipeline(
        shaderLibrary['InstancedSceneVertex']!, shaderLibrary['SceneFragment']!,
        vertexLayout: standardVertexLayout);


    // --- Geometry Data ---
    final List<double> cubeVertexData = [
      -1,1,-1, 0,1,0, 1,1,0,1,  -1,1,1, 0,1,0, 1,1,0,1,  1,1,1, 0,1,0, 1,1,0,1,  1,1,-1, 0,1,0, 1,1,0,1,
      -1,-1,-1, 0,-1,0, 0,1,1,1,  1,-1,-1, 0,-1,0, 0,1,1,1,  1,-1,1, 0,-1,0, 0,1,1,1,  -1,-1,1, 0,-1,0, 0,1,1,1,
      -1,-1,-1, -1,0,0, 1,0,0,1,  -1,-1,1, -1,0,0, 1,0,0,1,  -1,1,1, -1,0,0, 1,0,0,1,  -1,1,-1, -1,0,0, 1,0,0,1,
      1,-1,-1, 1,0,0, 0,1,0,1,  1,1,-1, 1,0,0, 0,1,0,1,  1,1,1, 1,0,0, 0,1,0,1,  1,-1,1, 1,0,0, 0,1,0,1,
      -1,-1,-1, 0,0,-1, 0,0,1,1,  -1,1,-1, 0,0,-1, 0,0,1,1,  1,1,-1, 0,0,-1, 0,0,1,1,  1,-1,-1, 0,0,-1, 0,0,1,1,
      -1,-1,1, 0,0,1, 1,0,1,1,  1,-1,1, 0,0,1, 1,0,1,1,  1,1,1, 0,0,1, 1,0,1,1,  -1,1,1, 0,0,1, 1,0,1,1,
    ];
    _cubeVertexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, float32(cubeVertexData).lengthInBytes);
    _cubeVertexBuffer!.overwrite(float32(cubeVertexData));

    final List<int> cubeIndexData = [
      0,1,2, 0,2,3,  4,5,6, 4,6,7,  8,9,10, 8,10,11,
      12,13,14, 12,14,15,  16,17,18, 16,18,19,  20,21,22, 20,22,23
    ];
    _cubeIndexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, uint16(cubeIndexData).lengthInBytes);
    _cubeIndexBuffer!.overwrite(uint16(cubeIndexData));
    
    const int gridSize = 60; // Reduced slightly for wider compatibility
    const double spacing = 2.5;
    final List<double> instanceOffsets = [];
    for (int x = -gridSize; x <= gridSize; x++) {
      for (int z = -gridSize; z <= gridSize; z++) {
        if (x == 0 && z == 0) continue; // Don't draw a cube where the player is
        instanceOffsets.addAll([x * spacing, 0.0, z * spacing]);
      }
    }
    _instanceCount = instanceOffsets.length ~/ 3;
    final instanceData = float32(instanceOffsets);
    _instanceOffsetBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, instanceData.lengthInBytes);
    _instanceOffsetBuffer!.overwrite(instanceData);
  }

  @override
  void paint(Canvas canvas, Size size) {
    _initializeGeometryAndPipeline();

    final gpu.Texture? renderTexture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate, size.width.toInt(), size.height.toInt(), enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (renderTexture == null) return;
    final gpu.Texture? depthTexture = gpu.gpuContext.createTexture(gpu.StorageMode.deviceTransient, size.width.toInt(), size.height.toInt(), format: gpu.gpuContext.defaultDepthStencilFormat, enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (depthTexture == null) return;
    final commandBuffer = gpu.gpuContext.createCommandBuffer();
    final renderTarget = gpu.RenderTarget.singleColor(gpu.ColorAttachment(texture: renderTexture, clearValue: vec.Vector4(0.05, 0.06, 0.08, 1.0)), depthStencilAttachment: gpu.DepthStencilAttachment(texture: depthTexture, depthClearValue: 1.0));
    final pass = commandBuffer.createRenderPass(renderTarget);
    pass.setDepthWriteEnable(true);
    pass.setDepthCompareOperation(gpu.CompareFunction.less);

    final cameraFocusPoint = playerPosition;
    final cameraPosition = vec.Vector3(cameraDistance * sin(cameraOrbit.x) * sin(cameraOrbit.y), cameraDistance * cos(cameraOrbit.y), cameraDistance * cos(cameraOrbit.x) * sin(cameraOrbit.y)) + cameraFocusPoint;
    final viewMatrix = vec.makeViewMatrix(cameraPosition, cameraFocusPoint, vec.Vector3(0, 1, 0));
    final projectionMatrix = vec.makePerspectiveMatrix(pi / 4, size.width / size.height, 0.1, 1000.0);
    final viewProjectionMatrix = projectionMatrix * viewMatrix;

    final lightInfoSlot = _instancedPipeline!.fragmentShader.getUniformSlot('LightInfo');
    final lightInfoData = Float32List.fromList([0.5, -1.0, -0.5, 0.0, 0.9, 0.85, 0.7, 1.0, 0.1, 0.12, 0.15, 1.0]);
    pass.bindUniform(lightInfoSlot, gpu.gpuContext.createHostBuffer().emplace(lightInfoData.buffer.asByteData()));
    
    // --- Draw Instanced Cubes ---
    pass.bindPipeline(_instancedPipeline!);
    final sceneInfoSlot = _instancedPipeline!.vertexShader.getUniformSlot('SceneInfo');
    final modelMatrix = vec.Matrix4.identity();
    final mvp = viewProjectionMatrix * modelMatrix;
    final sceneInfoData = Float32List.fromList([...mvp.storage, ...modelMatrix.storage, time]);
    pass.bindUniform(sceneInfoSlot, gpu.gpuContext.createHostBuffer().emplace(sceneInfoData.buffer.asByteData()));
    
    pass.bindVertexBuffer(_cubeVertexBuffer!, 24, bufferSlot: 0); // Bind cube geometry to slot 0
    pass.bindVertexBuffer(_instanceOffsetBuffer!, _instanceCount, bufferSlot: 1); // Bind instance offsets to slot 1
    pass.bindIndexBuffer(_cubeIndexBuffer!, _cubeIndexCount, gpu.IndexType.int16);
    pass.draw(instanceCount: _instanceCount); // FIX: Use instanceCount parameter

    // --- Draw the Player Cube ---
    pass.bindPipeline(_playerPipeline!); // Use the simpler pipeline
    final playerModelMatrix = vec.Matrix4.translation(playerPosition)..scale(1.0, 1.5, 1.0); // Make player taller
    final playerMvp = viewProjectionMatrix * playerModelMatrix;
    // We set instance_offset to 0,0,0 in the shader which means it just uses a_position.
    final playerSceneInfoData = Float32List.fromList([...playerMvp.storage, ...playerModelMatrix.storage, time]);
    pass.bindUniform(sceneInfoSlot, gpu.gpuContext.createHostBuffer().emplace(playerSceneInfoData.buffer.asByteData()));
    pass.bindVertexBuffer(_cubeVertexBuffer!, 24, bufferSlot: 0);
    pass.bindIndexBuffer(_cubeIndexBuffer!, _cubeIndexCount, gpu.IndexType.int16);
    pass.draw(); // Regular draw for the player

    commandBuffer.submit();
    final image = renderTexture.asImage();
    canvas.drawImage(image, Offset.zero, Paint());
  }

  @override
  bool shouldRepaint(covariant InstancedScenePainter oldDelegate) {
    return oldDelegate.cameraOrbit != cameraOrbit ||
        oldDelegate.cameraDistance != cameraDistance ||
        oldDelegate.playerPosition != playerPosition ||
        oldDelegate.time != time;
  }
}*/

/*// --------------------------------------------------
// Source: lib\game_demo.dart (FINAL WORKING VERSION)
// --------------------------------------------------

class GameDemoPage extends StatefulWidget {
  const GameDemoPage({super.key});
  @override
  State<GameDemoPage> createState() => _GameDemoPageState();
}

class _GameDemoPageState extends State<GameDemoPage> {
  vec.Vector3 _cameraOrbit = vec.Vector3(0.8, 1.2, 0.0);
  double _cameraDistance = 15.0;
  vec.Vector3 _playerPosition = vec.Vector3.zero();
  final Set<LogicalKeyboardKey> _keysPressed = {};
  Ticker? _ticker;
  double _time = 0;
  final FocusNode _focusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    _ticker = Ticker((elapsed) {
      if (mounted) setState(() => _time = elapsed.inMilliseconds / 1000.0);
    });
    _ticker!.start();
  }

  @override
  void dispose() {
    _ticker?.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  void _handleKeyEvent(KeyEvent event) {
    setState(() {
      if (event is KeyDownEvent) _keysPressed.add(event.logicalKey);
      else if (event is KeyUpEvent) _keysPressed.remove(event.logicalKey);
    });
  }

  void _updatePlayerPosition() {
    const double moveSpeed = 0.1;
    final moveDirection = vec.Vector3.zero();
    if (_keysPressed.contains(LogicalKeyboardKey.keyW)) moveDirection.z -= moveSpeed;
    if (_keysPressed.contains(LogicalKeyboardKey.keyS)) moveDirection.z += moveSpeed;
    if (_keysPressed.contains(LogicalKeyboardKey.keyA)) moveDirection.x -= moveSpeed;
    if (_keysPressed.contains(LogicalKeyboardKey.keyD)) moveDirection.x += moveSpeed;
    _playerPosition += moveDirection;
  }

  @override
  Widget build(BuildContext context) {
    FocusScope.of(context).requestFocus(_focusNode);
    _updatePlayerPosition();
    return KeyboardListener(
      focusNode: _focusNode,
      onKeyEvent: _handleKeyEvent,
      child: GestureDetector(
        onPanUpdate: (details) => setState(() {
          _cameraOrbit.x += details.delta.dx * 0.01;
          _cameraOrbit.y -= details.delta.dy * 0.01;
          _cameraOrbit.y = _cameraOrbit.y.clamp(0.1, pi - 0.1);
        }),
        child: CustomPaint(
          size: Size.infinite,
          painter: GameScenePainter(
            cameraOrbit: _cameraOrbit,
            cameraDistance: _cameraDistance,
            playerPosition: _playerPosition,
            time: _time,
          ),
        ),
      ),
    );
  }
}

class GameScenePainter extends CustomPainter {
  GameScenePainter({
    required this.cameraOrbit,
    required this.cameraDistance,
    required this.playerPosition,
    required this.time,
  });

  final vec.Vector3 cameraOrbit;
  final double cameraDistance;
  final vec.Vector3 playerPosition;
  final double time;

  static gpu.DeviceBuffer? _cubeVertexBuffer;
  static gpu.DeviceBuffer? _cubeIndexBuffer;
  static gpu.RenderPipeline? _pipeline;
  static const int _cubeIndexCount = 36;
  static const int _cubeVertexCount = 24;
  static bool _initialized = false;

  void _initializeGeometryAndPipeline(gpu.GpuContext context) {
    if (_initialized) return;

    _pipeline = context.createRenderPipeline(
        shaderLibrary['GameSceneVertex']!, shaderLibrary['GameSceneFragment']!);

    // FINAL FIX: Provide Position (3), Normal (3), and Color (4) for each vertex.
    final List<double> cubeVertexData = [
      // Top face (yellow)
      -1,1,-1,  0,1,0,  1,1,0,1,  -1,1,1,  0,1,0,  1,1,0,1,  1,1,1,  0,1,0,  1,1,0,1,  1,1,-1,  0,1,0,  1,1,0,1,
      // Bottom face (cyan)
      -1,-1,-1, 0,-1,0, 0,1,1,1,  1,-1,-1, 0,-1,0, 0,1,1,1,  1,-1,1, 0,-1,0, 0,1,1,1,  -1,-1,1, 0,-1,0, 0,1,1,1,
      // Left face (red)
      -1,-1,-1, -1,0,0, 1,0,0,1,  -1,-1,1, -1,0,0, 1,0,0,1,  -1,1,1, -1,0,0, 1,0,0,1,  -1,1,-1, -1,0,0, 1,0,0,1,
      // Right face (green)
      1,-1,-1, 1,0,0, 0,1,0,1,  1,1,-1, 1,0,0, 0,1,0,1,  1,1,1, 1,0,0, 0,1,0,1,  1,-1,1, 1,0,0, 0,1,0,1,
      // Back face (blue)
      -1,-1,-1, 0,0,-1, 0,0,1,1,  -1,1,-1, 0,0,-1, 0,0,1,1,  1,1,-1, 0,0,-1, 0,0,1,1,  1,-1,-1, 0,0,-1, 0,0,1,1,
      // Front face (magenta)
      -1,-1,1, 0,0,1, 1,0,1,1,  1,-1,1, 0,0,1, 1,0,1,1,  1,1,1, 0,0,1, 1,0,1,1,  -1,1,1, 0,0,1, 1,0,1,1,
    ];
    _cubeVertexBuffer = context.createDeviceBuffer(gpu.StorageMode.hostVisible, float32(cubeVertexData).lengthInBytes);
    _cubeVertexBuffer!.overwrite(float32(cubeVertexData));

    final List<int> cubeIndexData = [
      0,1,2, 0,2,3,  4,5,6, 4,6,7,  8,9,10, 8,10,11,
      12,13,14, 12,14,15,  16,17,18, 16,18,19,  20,21,22, 20,22,23
    ];
    _cubeIndexBuffer = context.createDeviceBuffer(gpu.StorageMode.hostVisible, uint16(cubeIndexData).lengthInBytes);
    _cubeIndexBuffer!.overwrite(uint16(cubeIndexData));
    _initialized = true;
  }

  @override
  void paint(Canvas canvas, Size size) {
    _initializeGeometryAndPipeline(gpu.gpuContext);

    final gpu.Texture? renderTexture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate, size.width.toInt(), size.height.toInt(), enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (renderTexture == null) return;
    final gpu.Texture? depthTexture = gpu.gpuContext.createTexture(gpu.StorageMode.deviceTransient, size.width.toInt(), size.height.toInt(), format: gpu.gpuContext.defaultDepthStencilFormat, enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (depthTexture == null) return;
    final commandBuffer = gpu.gpuContext.createCommandBuffer();
    final renderTarget = gpu.RenderTarget.singleColor(gpu.ColorAttachment(texture: renderTexture, clearValue: vec.Vector4(0.05, 0.06, 0.08, 1.0)), depthStencilAttachment: gpu.DepthStencilAttachment(texture: depthTexture, depthClearValue: 1.0));
    final pass = commandBuffer.createRenderPass(renderTarget);
    pass.setDepthWriteEnable(true);
    pass.setDepthCompareOperation(gpu.CompareFunction.less);
    pass.bindPipeline(_pipeline!);

    final cameraFocusPoint = playerPosition;
    final cameraPosition = vec.Vector3(cameraDistance * sin(cameraOrbit.x) * sin(cameraOrbit.y), cameraDistance * cos(cameraOrbit.y), cameraDistance * cos(cameraOrbit.x) * sin(cameraOrbit.y)) + cameraFocusPoint;
    final viewMatrix = vec.makeViewMatrix(cameraPosition, cameraFocusPoint, vec.Vector3(0, 1, 0));
    final projectionMatrix = vec.makePerspectiveMatrix(pi / 4, size.width / size.height, 0.1, 1000.0);
    final viewProjectionMatrix = projectionMatrix * viewMatrix;

    final transients = gpu.gpuContext.createHostBuffer();

    final sceneInfoSlot = _pipeline!.vertexShader.getUniformSlot('FrameInfo');
    final lightInfoSlot = _pipeline!.fragmentShader.getUniformSlot('LightInfo');
    final lightInfoData = Float32List.fromList([0.5, -1.0, -0.5, 0.0, 0.9, 0.85, 0.7, 1.0, 0.1, 0.12, 0.15, 1.0]);
    final lightInfoView = transients.emplace(lightInfoData.buffer.asByteData());
    pass.bindUniform(lightInfoSlot, lightInfoView);

    // Bind the vertex and index buffers once for all objects in the loop
    pass.bindVertexBuffer(gpu.BufferView(_cubeVertexBuffer!, offsetInBytes: 0, lengthInBytes: _cubeVertexBuffer!.sizeInBytes), _cubeVertexCount);
    pass.bindIndexBuffer(gpu.BufferView(_cubeIndexBuffer!, offsetInBytes: 0, lengthInBytes: _cubeIndexBuffer!.sizeInBytes), gpu.IndexType.int16, _cubeIndexCount);

    // --- Draw the world cubes via a CPU loop ---
    const int gridSize = 10;
    const double spacing = 2.5;
    for (int x = -gridSize; x <= gridSize; x++) {
      for (int z = -gridSize; z <= gridSize; z++) {
        if (x == 0 && z == 0) continue;

        final yOffset = 0.25 * sin(x + z + time * 2.0);
        final position = vec.Vector3(x * spacing, yOffset, z * spacing);
        final modelMatrix = vec.Matrix4.translation(position);
        final mvp = viewProjectionMatrix * modelMatrix;
        
        final sceneInfoData = float32Mat(mvp);
        final sceneInfoView = transients.emplace(sceneInfoData);
        pass.bindUniform(sceneInfoSlot, sceneInfoView);
        pass.draw();
      }
    }

    // --- Draw the Player Cube ---
    final playerModelMatrix = vec.Matrix4.translation(playerPosition)..scale(1.0, 1.5, 1.0);
    final playerMvp = viewProjectionMatrix * playerModelMatrix;
    final playerSceneInfoData = float32Mat(playerMvp);
    final playerSceneInfoView = transients.emplace(playerSceneInfoData);
    pass.bindUniform(sceneInfoSlot, playerSceneInfoView);
    pass.draw();

    commandBuffer.submit();
    final image = renderTexture.asImage();
    canvas.drawImage(image, Offset.zero, Paint());
  }

  @override
  bool shouldRepaint(covariant GameScenePainter oldDelegate) {
    return oldDelegate.cameraOrbit != cameraOrbit ||
        oldDelegate.cameraDistance != cameraDistance ||
        oldDelegate.playerPosition != playerPosition ||
        oldDelegate.time != time;
  }
}*/

// --------------------------------------------------
// Source: lib\game_demo.dart (FINAL BUILD FIX)
// --------------------------------------------------

class EnemyCube {
  vec.Vector3 position;
  bool isAlive = true;
  double timeToDie = -1.0;

  EnemyCube(this.position);
}

class Projectile {
  vec.Vector3 position;
  vec.Vector3 direction;
  Projectile(this.position, this.direction);
}

class GameDemoPage extends StatefulWidget {
  const GameDemoPage({super.key});
  @override
  State<GameDemoPage> createState() => _GameDemoPageState();
}

class _GameDemoPageState extends State<GameDemoPage> {
  // --- UI & Camera ---
  vec.Vector3 _cameraOrbit = vec.Vector3(0.8, 1.2, 0.0);
  double _cameraDistance = 25.0;
  final FocusNode _focusNode = FocusNode();

  // --- Game State ---
  vec.Vector3 _playerPosition = vec.Vector3.zero();
  final List<EnemyCube> _enemies = [];
  final List<Projectile> _projectiles = [];
  final Queue<LogicalKeyboardKey> _keyQueue = Queue();
  double _lastShotTime = 0.0;
  
  // --- Animation & Game Loop ---
  Ticker? _ticker;
  double _time = 0;
  double _lastFrameTime = 0;

  // --- GPU Resources ---
  gpu.DeviceBuffer? _cubeVertexBuffer;
  gpu.DeviceBuffer? _cubeIndexBuffer;
  gpu.RenderPipeline? _interactivePipeline;

  @override
  void initState() {
    super.initState();
    // --- Initialize Game World ---
    const int gridSize = 10;
    const double spacing = 2.5;
    for (int x = -gridSize; x <= gridSize; x++) {
      for (int z = -gridSize; z <= gridSize; z++) {
        _enemies.add(EnemyCube(vec.Vector3(x * spacing, 0, z * spacing)));
      }
    }
    
    // --- Create GPU resources ---
    _interactivePipeline = gpu.gpuContext.createRenderPipeline(
        shaderLibrary['InteractiveGameVertex']!, shaderLibrary['GameSceneFragment']!);

    // Data includes position, normal, and color
    final List<double> cubeVertexData = [
      -1,1,-1,0,1,0,1,1,0,1, -1,1,1,0,1,0,1,1,0,1, 1,1,1,0,1,0,1,1,0,1, 1,1,-1,0,1,0,1,1,0,1,
      -1,-1,-1,0,-1,0,0,1,1,1, 1,-1,-1,0,-1,0,0,1,1,1, 1,-1,1,0,-1,0,0,1,1,1, -1,-1,1,0,-1,0,0,1,1,1,
      -1,-1,-1,-1,0,0,1,0,0,1, -1,-1,1,-1,0,0,1,0,0,1, -1,1,1,-1,0,0,1,0,0,1, -1,1,-1,-1,0,0,1,0,0,1,
      1,-1,-1,1,0,0,0,1,0,1, 1,1,-1,1,0,0,0,1,0,1, 1,1,1,1,0,0,0,1,0,1, 1,-1,1,1,0,0,0,1,0,1,
      -1,-1,-1,0,0,-1,0,0,1,1, -1,1,-1,0,0,-1,0,0,1,1, 1,1,-1,0,0,-1,0,0,1,1, 1,-1,-1,0,0,-1,0,0,1,1,
      -1,-1,1,0,0,1,1,0,1,1, 1,-1,1,0,0,1,1,0,1,1, 1,1,1,0,0,1,1,0,1,1, -1,1,1,0,0,1,1,0,1,1,
    ];
    _cubeVertexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, float32(cubeVertexData).lengthInBytes);
    _cubeVertexBuffer!.overwrite(float32(cubeVertexData));

    final List<int> cubeIndexData = [
      0,1,2, 0,2,3, 4,5,6, 4,6,7, 8,9,10, 8,10,11, 12,13,14, 12,14,15,
      16,17,18, 16,18,19, 20,21,22, 20,22,23
    ];
    _cubeIndexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, uint16(cubeIndexData).lengthInBytes);
    _cubeIndexBuffer!.overwrite(uint16(cubeIndexData));
    
    // --- Start Ticker for Game Loop ---
    _ticker = Ticker(_gameLoop);
    _ticker!.start();
  }
  
  void _gameLoop(Duration elapsed) {
    if (!mounted) return;
    
    final currentTime = elapsed.inMilliseconds / 1000.0;
    final deltaTime = (currentTime - _lastFrameTime).clamp(0.0, 0.05);
    _lastFrameTime = currentTime;
    
    _handlePlayerMovement(deltaTime);
    _updateProjectiles(deltaTime);
    _checkCollisions();

    setState(() {
      _time = currentTime;
    });
  }

  void _handlePlayerMovement(double deltaTime) {
    const double moveSpeed = 10.0;
    if (_keyQueue.isEmpty) return;
    final key = _keyQueue.first;
    if(key == LogicalKeyboardKey.keyW) _playerPosition.z -= moveSpeed * deltaTime;
    if(key == LogicalKeyboardKey.keyS) _playerPosition.z += moveSpeed * deltaTime;
    if(key == LogicalKeyboardKey.keyA) _playerPosition.x -= moveSpeed * deltaTime;
    if(key == LogicalKeyboardKey.keyD) _playerPosition.x += moveSpeed * deltaTime;
  }
  
  void _shoot() {
    if (_time - _lastShotTime < 0.2) return;
    _lastShotTime = _time;

    // FIX: Access _cameraOrbit, not cameraOrbit
    final fireDirection = vec.Vector3(
      -sin(_cameraOrbit.x) * sin(_cameraOrbit.y),
      0,
      -cos(_cameraOrbit.x) * sin(_cameraOrbit.y),
    ).normalized();
    
    _projectiles.add(Projectile(_playerPosition + fireDirection * 1.5, fireDirection));
  }

  void _updateProjectiles(double deltaTime) {
    const double projectileSpeed = 30.0;
    _projectiles.forEach((p) => p.position += p.direction * projectileSpeed * deltaTime);
    _projectiles.removeWhere((p) => p.position.length > 50);
  }
  
  void _checkCollisions() {
    for (final projectile in _projectiles) {
      for (final enemy in _enemies) {
        if (enemy.isAlive) {
          final dist = projectile.position - enemy.position;
          if (dist.x.abs() < 1 && dist.y.abs() < 1 && dist.z.abs() < 1) {
            enemy.isAlive = false;
            enemy.timeToDie = _time;
            projectile.position.y = -1000;
            break;
          }
        }
      }
    }
    _projectiles.removeWhere((p) => p.position.y == -1000);
  }
  
  @override
  void dispose() {
    _ticker?.dispose();
    _focusNode.dispose();
    
    // FIX: Removed calls to .dispose() on GPU resources as they don't exist in this API version.
    // NOTE: This implies a resource leak is inherent to this older version of flutter_gpu.
    // The resources will only be reclaimed when the application is fully terminated.
    _cubeVertexBuffer = null;
    _cubeIndexBuffer = null;
    _interactivePipeline = null;

    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    FocusScope.of(context).requestFocus(_focusNode);

    if (_interactivePipeline == null) return const Center(child: CircularProgressIndicator());

    return RawKeyboardListener(
      focusNode: _focusNode,
      onKey: (event) {
        if (event is RawKeyDownEvent) {
          if (!_keyQueue.contains(event.logicalKey)) _keyQueue.addLast(event.logicalKey);
        } else if (event is RawKeyUpEvent) {
          _keyQueue.remove(event.logicalKey);
        }
      },
      child: GestureDetector(
        onPanUpdate: (details) => setState(() {
          _cameraOrbit.x += details.delta.dx * 0.01;
          _cameraOrbit.y -= details.delta.dy * 0.01;
          _cameraOrbit.y = _cameraOrbit.y.clamp(0.1, pi - 0.1);
        }),
        onTap: _shoot,
        child: CustomPaint(
          size: Size.infinite,
          painter: GameScenePainter(
            pipeline: _interactivePipeline!,
            vertexBuffer: _cubeVertexBuffer!,
            indexBuffer: _cubeIndexBuffer!,
            cameraOrbit: _cameraOrbit,
            cameraDistance: _cameraDistance,
            playerPosition: _playerPosition,
            enemies: _enemies,
            projectiles: _projectiles,
            time: _time,
          ),
        ),
      ),
    );
  }
}

class GameScenePainter extends CustomPainter {
  GameScenePainter({
    required this.pipeline,
    required this.vertexBuffer,
    required this.indexBuffer,
    required this.cameraOrbit,
    required this.cameraDistance,
    required this.playerPosition,
    required this.enemies,
    required this.projectiles,
    required this.time,
  });

  final gpu.RenderPipeline pipeline;
  final gpu.DeviceBuffer vertexBuffer;
  final gpu.DeviceBuffer indexBuffer;
  final vec.Vector3 cameraOrbit;
  final double cameraDistance;
  final vec.Vector3 playerPosition;
  final List<EnemyCube> enemies;
  final List<Projectile> projectiles;
  final double time;

  static const int _cubeIndexCount = 36;
  static const int _cubeVertexCount = 24;

  @override
  void paint(Canvas canvas, Size size) {
    final gpu.Texture? renderTexture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate, size.width.toInt(), size.height.toInt(), enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (renderTexture == null) return;
    final gpu.Texture? depthTexture = gpu.gpuContext.createTexture(gpu.StorageMode.deviceTransient, size.width.toInt(), size.height.toInt(), format: gpu.gpuContext.defaultDepthStencilFormat, enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (depthTexture == null) return;
    final commandBuffer = gpu.gpuContext.createCommandBuffer();
    final renderTarget = gpu.RenderTarget.singleColor(gpu.ColorAttachment(texture: renderTexture, clearValue: vec.Vector4(0.05, 0.06, 0.08, 1.0)), depthStencilAttachment: gpu.DepthStencilAttachment(texture: depthTexture, depthClearValue: 1.0));
    final pass = commandBuffer.createRenderPass(renderTarget);
    pass.setDepthWriteEnable(true);
    pass.setDepthCompareOperation(gpu.CompareFunction.less);
    pass.bindPipeline(pipeline);

    final cameraFocusPoint = playerPosition;
    final cameraPosition = vec.Vector3(cameraDistance * sin(cameraOrbit.x) * sin(cameraOrbit.y), cameraDistance * cos(cameraOrbit.y), cameraDistance * cos(cameraOrbit.x) * sin(cameraOrbit.y)) + cameraFocusPoint;
    final viewMatrix = vec.makeViewMatrix(cameraPosition, cameraFocusPoint, vec.Vector3(0, 1, 0));
    final projectionMatrix = vec.makePerspectiveMatrix(pi / 4, size.width / size.height, 0.1, 1000.0);
    final viewProjectionMatrix = projectionMatrix * viewMatrix;

    final transients = gpu.gpuContext.createHostBuffer();
    final sceneInfoSlot = pipeline.vertexShader.getUniformSlot('FrameInfo');
    final lightInfoSlot = pipeline.fragmentShader.getUniformSlot('LightInfo');
    final lightInfoData = Float32List.fromList([0.5, -1.0, -0.5, 0.0, 0.9, 0.85, 0.7, 1.0, 0.15, 0.15, 0.2, 1.0]);
    final lightInfoView = transients.emplace(lightInfoData.buffer.asByteData());
    pass.bindUniform(lightInfoSlot, lightInfoView);

    pass.bindVertexBuffer(gpu.BufferView(vertexBuffer, offsetInBytes: 0, lengthInBytes: vertexBuffer.sizeInBytes), _cubeVertexCount);
    pass.bindIndexBuffer(gpu.BufferView(indexBuffer, offsetInBytes: 0, lengthInBytes: indexBuffer.sizeInBytes), gpu.IndexType.int16, _cubeIndexCount);

    // --- Draw Enemy Cubes ---
    const double deathAnimationDuration = 0.5;
    for (final enemy in enemies) {
      double animState = 0.0;
      if (!enemy.isAlive) {
        animState = (time - enemy.timeToDie) / deathAnimationDuration;
        if (animState >= 1.0) continue;
      }
      
      final modelMatrix = vec.Matrix4.translation(enemy.position);
      final mvp = viewProjectionMatrix * modelMatrix;

      // FINAL FIX: Create a new list with all 18 floats, then convert.
      final List<double> uniformData = [...mvp.storage, time, animState];
      final sceneInfoData = float32(uniformData);
      final sceneInfoView = transients.emplace(sceneInfoData);
      pass.bindUniform(sceneInfoSlot, sceneInfoView);
      pass.draw();
    }
    
    // --- Draw Projectiles ---
    for (final projectile in projectiles) {
      final modelMatrix = vec.Matrix4.translation(projectile.position)..scale(0.15, 0.15, 0.8);
      final mvp = viewProjectionMatrix * modelMatrix;
      
      // FINAL FIX: Create a new list with all 18 floats, then convert.
      final List<double> uniformData = [...mvp.storage, time, 0.0];
      final sceneInfoData = float32(uniformData);
      final sceneInfoView = transients.emplace(sceneInfoData);
      pass.bindUniform(sceneInfoSlot, sceneInfoView);
      pass.draw();
    }
    
    // --- Draw Player Cube ---
    final playerModelMatrix = vec.Matrix4.translation(playerPosition)..scale(1.0, 1.5, 1.0);
    final playerMvp = viewProjectionMatrix * playerModelMatrix;

    // FINAL FIX: Create a new list with all 18 floats, then convert.
    final List<double> uniformData = [...playerMvp.storage, time, 0.0];
    final sceneInfoData = float32(uniformData);
    final playerSceneInfoView = transients.emplace(sceneInfoData);
    pass.bindUniform(sceneInfoSlot, playerSceneInfoView);
    pass.draw();

    commandBuffer.submit();
    final image = renderTexture.asImage();
    canvas.drawImage(image, Offset.zero, Paint());
  }

  @override
  bool shouldRepaint(covariant GameScenePainter oldDelegate) => true;
}

/*// --------------------------------------------------
// Source: lib\benchmark_page.dart (FINAL ROBUST VERSION)
// --------------------------------------------------

enum BenchmarkMethod {
  flutterGpuPipeline,
  fragmentShaderRaymarch,
}

class BenchmarkPage extends StatefulWidget {
  const BenchmarkPage({super.key});

  @override
  State<BenchmarkPage> createState() => _BenchmarkPageState();
}

class _BenchmarkPageState extends State<BenchmarkPage> {
  BenchmarkMethod _method = BenchmarkMethod.flutterGpuPipeline;
  Ticker? _ticker;
  double _time = 0;
  int _frameCount = 0;
  double _fps = 60.0;
  double _lastFpsUpdateTime = 0;
  
  // Resources for Pipeline Method
  gpu.DeviceBuffer? _cubeVertexBuffer;
  gpu.DeviceBuffer? _cubeIndexBuffer;
  gpu.RenderPipeline? _pipeline;

  // Resources for Raymarch Method
  gpu.RenderPipeline? _raymarchPipeline;
  gpu.DeviceBuffer? _dummyVertexBuffer;
  bool _shadersLoaded = false;

  @override
  void initState() {
    super.initState();
    _initializeResources();
    
    _ticker = Ticker((elapsed) {
      if (mounted) setState(() {
          _time = elapsed.inMilliseconds / 1000.0;
          _frameCount++;
          if (_time - _lastFpsUpdateTime > 1.0) {
            _fps = _frameCount / (_time - _lastFpsUpdateTime);
            _lastFpsUpdateTime = _time;
            _frameCount = 0;
          }
      });
    });
    _ticker!.start();
  }
  
  void _initializeResources() {
    // FINAL FIX: Load shaders safely without the '!' operator
    final gameSceneVertex = shaderLibrary['GameSceneVertex'];
    final gameSceneFragment = shaderLibrary['GameSceneFragment'];
    final raymarchVertex = shaderLibrary['RaymarchVertex'];
    final raymarchCube = shaderLibrary['RaymarchCube'];
    
    // If any shader failed to load, do not proceed. The build method will show an error.
    if (gameSceneVertex == null || gameSceneFragment == null || raymarchVertex == null || raymarchCube == null) {
      return;
    }
    
    _pipeline = gpu.gpuContext.createRenderPipeline(gameSceneVertex, gameSceneFragment);
    
    final List<double> cubeVertexData = [
      -1,1,-1,  0,1,0,  1,1,0,1,  -1,1,1,  0,1,0,  1,1,0,1,  1,1,1,  0,1,0,  1,1,0,1,  1,1,-1,  0,1,0,  1,1,0,1,
      -1,-1,-1, 0,-1,0, 0,1,1,1,  1,-1,-1, 0,-1,0, 0,1,1,1,  1,-1,1, 0,-1,0, 0,1,1,1,  -1,-1,1, 0,-1,0, 0,1,1,1,
      -1,-1,-1, -1,0,0, 1,0,0,1,  -1,-1,1, -1,0,0, 1,0,0,1,  -1,1,1, -1,0,0, 1,0,0,1,  -1,1,-1, -1,0,0, 1,0,0,1,
      1,-1,-1, 1,0,0, 0,1,0,1,  1,1,-1, 1,0,0, 0,1,0,1,  1,1,1, 1,0,0, 0,1,0,1,  1,-1,1, 1,0,0, 0,1,0,1,
      -1,-1,-1, 0,0,-1, 0,0,1,1,  -1,1,-1, 0,0,-1, 0,0,1,1,  1,1,-1, 0,0,-1, 0,0,1,1,  1,-1,-1, 0,0,-1, 0,0,1,1,
      -1,-1,1, 0,0,1, 1,0,1,1,  1,-1,1, 0,0,1, 1,0,1,1,  1,1,1, 0,0,1, 1,0,1,1,  -1,1,1, 0,0,1, 1,0,1,1,
    ];
    _cubeVertexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, float32(cubeVertexData).lengthInBytes);
    _cubeVertexBuffer!.overwrite(float32(cubeVertexData));

    final List<int> cubeIndexData = [
      0,1,2, 0,2,3,  4,5,6, 4,6,7,  8,9,10, 8,10,11, 12,13,14, 12,14,15,
      16,17,18, 16,18,19, 20,21,22, 20,22,23
    ];
    _cubeIndexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, uint16(cubeIndexData).lengthInBytes);
    _cubeIndexBuffer!.overwrite(uint16(cubeIndexData));
    
    _raymarchPipeline = gpu.gpuContext.createRenderPipeline(raymarchVertex, raymarchCube);
    _dummyVertexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, 1);

    _shadersLoaded = true;
  }
  
  @override
  void dispose() {
    _ticker?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!_shadersLoaded) {
      return const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('Error: Shaders not found!', style: TextStyle(color: Colors.red, fontSize: 18)),
            SizedBox(height: 8),
            Text('Ensure TestLibrary.shaderbundle.json is correct and re-run shader compiler script.'),
            SizedBox(height: 24),
            CircularProgressIndicator(),
          ],
        ),
      );
    }

    final bool isPipeline = _method == BenchmarkMethod.flutterGpuPipeline;
    final String methodName = isPipeline ? "Vertex + Fragment Pipeline" : "Fragment-Only Raymarching";

    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              Text(methodName, style: Theme.of(context).textTheme.headlineMedium),
              Text(
                'FPS: ${_fps.toStringAsFixed(1)}',
                style: TextStyle(
                  color: _fps > 50 ? Colors.green : (_fps > 30 ? Colors.orange : Colors.red),
                  fontSize: 24,
                  fontWeight: FontWeight.bold
                ),
              ),
              ElevatedButton(
                onPressed: () {
                  setState(() {
                    _method = isPipeline ? BenchmarkMethod.fragmentShaderRaymarch : BenchmarkMethod.flutterGpuPipeline;
                  });
                },
                child: const Text('Switch Method'),
              )
            ],
          ),
        ),
        Expanded(
          child: CustomPaint(
            size: Size.infinite,
            painter: BenchmarkPainter(
              method: _method,
              pipeline: _pipeline!,
              raymarchPipeline: _raymarchPipeline!,
              vertexBuffer: _cubeVertexBuffer!,
              indexBuffer: _cubeIndexBuffer!,
              dummyVertexBuffer: _dummyVertexBuffer!,
              time: _time,
            ),
          ),
        ),
      ],
    );
  }
}*/

/*// --------------------------------------------------
// Source: lib\benchmark_page.dart (FINAL STABLE VERSION)
// --------------------------------------------------

enum BenchmarkMethod {
  flutterGpuPipeline,
  fragmentShaderRaymarch,
}

class BenchmarkPage extends StatefulWidget {
  const BenchmarkPage({super.key});

  @override
  State<BenchmarkPage> createState() => _BenchmarkPageState();
}

class _BenchmarkPageState extends State<BenchmarkPage> {
  BenchmarkMethod _method = BenchmarkMethod.flutterGpuPipeline;
  Ticker? _ticker;
  double _time = 0;
  int _frameCount = 0;
  double _fps = 60.0;
  double _lastFpsUpdateTime = 0;
  
  gpu.DeviceBuffer? _cubeVertexBuffer;
  gpu.DeviceBuffer? _cubeIndexBuffer;
  gpu.RenderPipeline? _pipeline;

  gpu.RenderPipeline? _raymarchPipeline;
  gpu.DeviceBuffer? _dummyVertexBuffer;
  bool _shadersLoaded = false;

  @override
  void initState() {
    super.initState();
    _initializeResources();
    
    _ticker = Ticker((elapsed) {
      if (mounted) setState(() {
          _time = elapsed.inMilliseconds / 1000.0;
          _frameCount++;
          if (_time - _lastFpsUpdateTime > 1.0) {
            _fps = _frameCount / (_time - _lastFpsUpdateTime);
            _lastFpsUpdateTime = _time;
            _frameCount = 0;
          }
      });
    });
    _ticker!.start();
  }
  
  void _initializeResources() {
    final gameSceneVertex = shaderLibrary['GameSceneVertex'];
    final gameSceneFragment = shaderLibrary['GameSceneFragment'];
    final raymarchVertex = shaderLibrary['RaymarchVertex'];
    final raymarchFragment = shaderLibrary['RaymarchFragment'];
    
    if (gameSceneVertex == null || gameSceneFragment == null || raymarchVertex == null || raymarchFragment == null) {
      return;
    }
    
    _pipeline = gpu.gpuContext.createRenderPipeline(gameSceneVertex, gameSceneFragment);
    
    final List<double> cubeVertexData = [
      -1,1,-1,  0,1,0,  1,1,0,1,  -1,1,1,  0,1,0,  1,1,0,1,  1,1,1,  0,1,0,  1,1,0,1,  1,1,-1,  0,1,0,  1,1,0,1,
      -1,-1,-1, 0,-1,0, 0,1,1,1,  1,-1,-1, 0,-1,0, 0,1,1,1,  1,-1,1, 0,-1,0, 0,1,1,1,  -1,-1,1, 0,-1,0, 0,1,1,1,
      -1,-1,-1, -1,0,0, 1,0,0,1,  -1,-1,1, -1,0,0, 1,0,0,1,  -1,1,1, -1,0,0, 1,0,0,1,  -1,1,-1, -1,0,0, 1,0,0,1,
      1,-1,-1, 1,0,0, 0,1,0,1,  1,1,-1, 1,0,0, 0,1,0,1,  1,1,1, 1,0,0, 0,1,0,1,  1,-1,1, 1,0,0, 0,1,0,1,
      -1,-1,-1, 0,0,-1, 0,0,1,1,  -1,1,-1, 0,0,-1, 0,0,1,1,  1,1,-1, 0,0,-1, 0,0,1,1,  1,-1,-1, 0,0,-1, 0,0,1,1,
      -1,-1,1, 0,0,1, 1,0,1,1,  1,-1,1, 0,0,1, 1,0,1,1,  1,1,1, 0,0,1, 1,0,1,1,  -1,1,1, 0,0,1, 1,0,1,1,
    ];
    _cubeVertexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, float32(cubeVertexData).lengthInBytes);
    _cubeVertexBuffer!.overwrite(float32(cubeVertexData));

    final List<int> cubeIndexData = [
      0,1,2, 0,2,3,  4,5,6, 4,6,7,  8,9,10, 8,10,11, 12,13,14, 12,14,15,
      16,17,18, 16,18,19, 20,21,22, 20,22,23
    ];
    _cubeIndexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, uint16(cubeIndexData).lengthInBytes);
    _cubeIndexBuffer!.overwrite(uint16(cubeIndexData));
    
    _raymarchPipeline = gpu.gpuContext.createRenderPipeline(raymarchVertex, raymarchFragment);
    _dummyVertexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, 1);

    _shadersLoaded = true;
  }
  
  @override
  void dispose() {
    _ticker?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!_shadersLoaded) {
      return const Center(
        child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [
          Text('Error: Shaders not found!', style: TextStyle(color: Colors.red, fontSize: 18)),
          SizedBox(height: 8), Text('Check shader filenames and re-run shader compiler.'),
        ]),
      );
    }
    
    final bool isPipeline = _method == BenchmarkMethod.flutterGpuPipeline;
    final String methodName = isPipeline ? "Vertex + Fragment Pipeline" : "Safe Fragment-Only Raymarching";

    return Column( children: [ /* ... UI ... */
      Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              Text(methodName, style: Theme.of(context).textTheme.headlineMedium),
              Text('FPS: ${_fps.toStringAsFixed(1)}', style: TextStyle(color: _fps > 50 ? Colors.green : (_fps > 30 ? Colors.orange : Colors.red), fontSize: 24, fontWeight: FontWeight.bold)),
              ElevatedButton(onPressed: () { setState(() { _method = isPipeline ? BenchmarkMethod.fragmentShaderRaymarch : BenchmarkMethod.flutterGpuPipeline; }); }, child: const Text('Switch Method'))
            ],
          ),
        ),
        Expanded(
          child: CustomPaint(
            size: Size.infinite,
            painter: BenchmarkPainter(
              method: _method,
              pipeline: _pipeline!,
              raymarchPipeline: _raymarchPipeline!,
              vertexBuffer: _cubeVertexBuffer!,
              indexBuffer: _cubeIndexBuffer!,
              dummyVertexBuffer: _dummyVertexBuffer!,
              time: _time,
            ),
          ),
        ),
    ]);
  }
}

class BenchmarkPainter extends CustomPainter {
  // ... constructor ...
  BenchmarkPainter({required this.method, required this.pipeline, required this.raymarchPipeline, required this.vertexBuffer, required this.indexBuffer, required this.dummyVertexBuffer, required this.time,});
  final BenchmarkMethod method;
  final gpu.RenderPipeline pipeline;
  final gpu.RenderPipeline raymarchPipeline;
  final gpu.DeviceBuffer vertexBuffer;
  final gpu.DeviceBuffer indexBuffer;
  final gpu.DeviceBuffer dummyVertexBuffer;
  final double time;

  @override
  void paint(Canvas canvas, Size size) {
    if (method == BenchmarkMethod.flutterGpuPipeline) {
      _paintWithPipeline(canvas, size);
    } else {
      _paintWithRaymarch(canvas, size);
    }
  }
  
  void _paintWithPipeline(Canvas canvas, Size size) {
    final gpu.Texture? renderTexture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate, size.width.toInt(), size.height.toInt(), enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (renderTexture == null) return;
    final gpu.Texture? depthTexture = gpu.gpuContext.createTexture(gpu.StorageMode.deviceTransient, size.width.toInt(), size.height.toInt(), format: gpu.gpuContext.defaultDepthStencilFormat, enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (depthTexture == null) return;
    final commandBuffer = gpu.gpuContext.createCommandBuffer();
    final renderTarget = gpu.RenderTarget.singleColor(gpu.ColorAttachment(texture: renderTexture, clearValue: vec.Vector4(0.05, 0.06, 0.08, 1.0)), depthStencilAttachment: gpu.DepthStencilAttachment(texture: depthTexture, depthClearValue: 1.0));
    final pass = commandBuffer.createRenderPass(renderTarget);
    pass.setDepthWriteEnable(true); pass.setDepthCompareOperation(gpu.CompareFunction.less);
    pass.bindPipeline(pipeline);

    final transients = gpu.gpuContext.createHostBuffer();
    final sceneInfoSlot = pipeline.vertexShader.getUniformSlot('FrameInfo');
    final lightInfoSlot = pipeline.fragmentShader.getUniformSlot('LightInfo');
    final lightInfoData = Float32List.fromList([5.0, 5.0, -5.0, 0.0, 0.9, 0.85, 0.7, 1.0, 0.15, 0.15, 0.2, 1.0]);
    pass.bindUniform(lightInfoSlot, transients.emplace(lightInfoData.buffer.asByteData()));
    pass.bindVertexBuffer(gpu.BufferView(vertexBuffer, offsetInBytes: 0, lengthInBytes: vertexBuffer.sizeInBytes), 24);
    pass.bindIndexBuffer(gpu.BufferView(indexBuffer, offsetInBytes: 0, lengthInBytes: indexBuffer.sizeInBytes), gpu.IndexType.int16, 36);
    
    final modelMatrix = vec.Matrix4.rotationY(time)..rotateX(time * 0.7);
    final viewMatrix = vec.makeViewMatrix(vec.Vector3(0,0,4), vec.Vector3(0,0,0), vec.Vector3(0,1,0));
    final projectionMatrix = vec.makePerspectiveMatrix(pi / 4, size.width / size.height, 0.1, 100.0);
    final mvp = projectionMatrix * viewMatrix * modelMatrix;
    final sceneInfoData = float32Mat(mvp);
    pass.bindUniform(sceneInfoSlot, transients.emplace(sceneInfoData));
    pass.draw();

    commandBuffer.submit();
    final image = renderTexture.asImage();
    canvas.drawImage(image, Offset.zero, Paint());
  }

  void _paintWithRaymarch(Canvas canvas, Size size) {
    final gpu.Texture? renderTexture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate, size.width.toInt(), size.height.toInt(), enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (renderTexture == null) return;
    final commandBuffer = gpu.gpuContext.createCommandBuffer();
    final renderTarget = gpu.RenderTarget.singleColor(gpu.ColorAttachment(texture: renderTexture));
    final pass = commandBuffer.createRenderPass(renderTarget);
    pass.bindPipeline(raymarchPipeline);
    
    final transients = gpu.gpuContext.createHostBuffer();
    final uniformSlot = raymarchPipeline.fragmentShader.getUniformSlot('Uniforms');
    
    // Updated uniform data for the safe shader
    final List<double> uniformData = [
      size.width, size.height, // iResolution (vec2) - no padding needed before float
      time, // iTime (float)
    ];
    // Need to pad to 16 bytes (vec4) boundary at the end
    uniformData.add(0.0);

    pass.bindUniform(uniformSlot, transients.emplace(float32(uniformData)));
    
    pass.bindVertexBuffer(gpu.BufferView(dummyVertexBuffer, offsetInBytes: 0, lengthInBytes: dummyVertexBuffer.sizeInBytes), 3);
    pass.draw();

    commandBuffer.submit();
    final image = renderTexture.asImage();
    canvas.drawImage(image, Offset.zero, Paint());
  }

  @override
  bool shouldRepaint(covariant BenchmarkPainter oldDelegate) => true;
}*/

// ... Main App and other demo pages follow ...
void main() { runApp(const MyApp()); }
class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
        useMaterial3: true,
      ),
      home: const DemoPage(),
    );
  }
}

class DemoPage extends StatefulWidget {
  const DemoPage({super.key});
  @override
  State<DemoPage> createState() => _DemoPageState();
}

class _DemoPageState extends State<DemoPage> {
  int widgetIndex = 0;

  @override
  Widget build(BuildContext context) {
    final widgets = [
      const GameDemoPage(), // The new hotness
	  // const BenchmarkPage(), // For Benchmarking November 2024 flutter_gpu Package's Public API VS The Fragement Shader API
      const ColorsPage(), // The rest are unchanged
      const TextureCubePage(),
      const TrianglePage(),
      const JuliaSetPage()
    ];
    final widgetsNames = <String>[
      'Game Demo - CPU Loop',
	  // "For Benchmarking November 2024 flutter_gpu Package's Public API VS The Fragement Shader API",
      'ColorsPage() - vert/uniform example',
      'TextureCubePage() - vert/indices/uniform/texture/depth example',
      'TrianglePage() - vert/uniform example',
      'JuliaSetPage() - Texture example'
    ];
    return Scaffold(
      appBar: AppBar(
        title: Row(children: [
          AnimatedOpacity(
            opacity: widgetIndex > 0 ? 1 : 0,
            duration: const Duration(milliseconds: 300),
            child: IconButton(
                onPressed: () => setState(() => widgetIndex = max(0, widgetIndex - 1)),
                icon: const Icon(Icons.arrow_back_ios)),
          ),
          Expanded(child: Text('GPU demo ${widgetsNames[widgetIndex]}', textAlign: TextAlign.center)),
          AnimatedOpacity(
            opacity: widgetIndex < widgets.length - 1 ? 1 : 0,
            duration: const Duration(milliseconds: 300),
            child: IconButton(
                onPressed: () => setState(() => widgetIndex = min(widgets.length - 1, widgetIndex + 1)),
                icon: const Icon(Icons.arrow_forward_ios)),
          ),
        ]),
      ),
      body: Column(mainAxisAlignment: MainAxisAlignment.center, children: [Expanded(child: widgets[widgetIndex])]),
    );
  }
}

// [For brevity, the rest of the file is omitted - just append your working versions of the other pages]

// --------------------------------------------------
// Source: .\lib\colors.dart
// --------------------------------------------------
class ColorsPainter extends CustomPainter {
  ColorsPainter(this.red, this.green, this.blue);
  double red, green, blue;

  @override
  void paint(Canvas canvas, Size size) {
    final gpu.Texture? texture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate, 300, 300);
    final vertex = shaderLibrary['ColorsVertex']!;
    final fragment = shaderLibrary['ColorsFragment']!;
    final pipeline = gpu.gpuContext.createRenderPipeline(vertex, fragment);
    final gpu.DeviceBuffer? vertexBuffer = gpu.gpuContext.createDeviceBuffer(gpu.StorageMode.hostVisible, 4 * 6 * 3);
    vertexBuffer!.overwrite(Float32List.fromList(<double>[-0.5,-0.5,1.0*red,0.0,0.0,1.0,0,0.5,0.0,1.0*green,0.0,1.0,0.5,-0.5,0.0,0.0,1.0*blue,1.0]).buffer.asByteData());
    final commandBuffer = gpu.gpuContext.createCommandBuffer();
    final renderTarget = gpu.RenderTarget.singleColor(gpu.ColorAttachment(texture: texture!));
    final pass = commandBuffer.createRenderPass(renderTarget);
    pass.bindPipeline(pipeline);
    pass.bindVertexBuffer(gpu.BufferView(vertexBuffer, offsetInBytes: 0, lengthInBytes: vertexBuffer.sizeInBytes), 3);
    pass.draw();
    commandBuffer.submit();
    final image = texture.asImage();
    canvas.drawImage(image, Offset(-texture.width / 2, 0), Paint());
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

class ColorsPage extends StatefulWidget {
  const ColorsPage({super.key});
  @override
  State<ColorsPage> createState() => _ColorsPageState();
}

class _ColorsPageState extends State<ColorsPage> {
  Ticker? tick;
  double time = 0, red = 1.0, green = 1.0, blue = 1.0;

  @override
  void initState() {
    super.initState();
    tick = Ticker((elapsed) => setState(() => time = elapsed.inMilliseconds / 1000.0));
    tick!.start();
  }

  @override
  void dispose() {
    tick?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(children: <Widget>[
      Slider(value: red, max: 1, min: 0, onChanged: (value) => {setState(() => red = value)}),
      Slider(value: green, max: 1, min: 0, onChanged: (value) => {setState(() => green = value)}),
      Slider(value: blue, max: 1, min: 0, onChanged: (value) => {setState(() => blue = value)}),
      CustomPaint(painter: ColorsPainter(red, green, blue)),
    ]);
  }
}

// --------------------------------------------------
// Source: .\lib\julia.dart
// --------------------------------------------------
class JuliaSetPainter extends CustomPainter {
  JuliaSetPainter(this.time, this.seedX, this.seedY);
  double time, seedX, seedY;
  final maxIterations = 100, escapeDistance = 10;

  @override
  void paint(Canvas canvas, Size size) {
    final gpu.Texture? texture = gpu.gpuContext.createTexture(gpu.StorageMode.hostVisible, 21, 9);
    if (texture == null) return;
    if (seedX > 0.0) {
      texture.overwrite(Uint32List.fromList(List<int>.generate(texture.width * texture.height, (int index) {
        int onColor = seedY < 0 ? (0xFF * seedY).toInt() | 0x00FFFF00 : (0xFF * -seedY).toInt() << 8 | 0x00FF00FF;
        return index.isEven ? (time.toInt().isEven ? onColor : 0xFF000000) : (time.toInt().isEven ? 0xFF000000 : onColor);
      }, growable: false)).buffer.asByteData());
    } else {
      var buffer = Int32List(texture.width * texture.height);
      for (int i = 0; i < buffer.length; i++) {
        int xi = i % texture.width, yi = i ~/ texture.width;
        double x = (xi.toDouble() - texture.width / 2) / (texture.width * 0.75), y = (yi.toDouble() - texture.height / 2) / (texture.height * 0.75);
        int iterations = 0;
        for (int it = 0; it < maxIterations; it++) {
          double newX = x * x - y * y + seedX;
          y = 2 * x * y + seedY;
          x = newX;
          if (x * x + y * y > escapeDistance * escapeDistance) {
            iterations = it;
            break;
          }
        }
        int shade = (iterations / maxIterations * 0xFF).toInt();
        buffer[i] = Color.fromARGB(0xFF, (shade * time).toInt(), (seedX * time).toInt(), (seedY * time).toInt()).value;
      }
      texture.overwrite(buffer.buffer.asByteData());
    }
    final ui.Image image = texture.asImage();
    canvas.scale(50);
    canvas.drawImage(image, Offset(-texture.width / 2, 0), Paint());
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

class JuliaSetPage extends StatefulWidget {
  const JuliaSetPage({super.key});
  @override
  State<JuliaSetPage> createState() => _JuliaSetPageState();
}

class _JuliaSetPageState extends State<JuliaSetPage> {
  Ticker? tick;
  double time = 0, seedX = -0.512511498387847167, seedY = 0.521295573094847167;

  @override
  void initState() {
    super.initState();
    tick = Ticker((elapsed) => setState(() => time = elapsed.inMilliseconds / 1000.0));
    tick!.start();
  }

  @override
  void dispose() {
    tick?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(children: <Widget>[
      Slider(value: seedX, max: 1, min: -1, onChanged: (value) => {setState(() => seedX = value)}),
      Slider(value: seedY, max: 1, min: -1, onChanged: (value) => {setState(() => seedY = value)}),
      CustomPaint(painter: JuliaSetPainter(time, seedX, seedY)),
    ]);
  }
}

// --------------------------------------------------
// Source: .\lib\texture_cube.dart
// --------------------------------------------------
class TextureCubePainter extends CustomPainter {
  TextureCubePainter(this.time, this.seedX, this.seedY, this.scale, this.depthClearValue);
  double time, seedX, seedY, scale, depthClearValue;

  @override
  void paint(Canvas canvas, Size size) {
    final gpu.Texture? renderTexture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate, 300, 300, enableRenderTargetUsage: true, enableShaderReadUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (renderTexture == null) return;
    final gpu.Texture? depthTexture = gpu.gpuContext.createTexture(gpu.StorageMode.deviceTransient, 300, 300, format: gpu.gpuContext.defaultDepthStencilFormat, enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (depthTexture == null) return;
    final commandBuffer = gpu.gpuContext.createCommandBuffer();
    final renderTarget = gpu.RenderTarget.singleColor(gpu.ColorAttachment(texture: renderTexture), depthStencilAttachment: gpu.DepthStencilAttachment(texture: depthTexture, depthClearValue: depthClearValue));
    final pass = commandBuffer.createRenderPass(renderTarget);
    final vertex = shaderLibrary['TextureVertex']!;
    final fragment = shaderLibrary['TextureFragment']!;
    final pipeline = gpu.gpuContext.createRenderPipeline(vertex, fragment);
    pass.bindPipeline(pipeline);
    pass.setDepthWriteEnable(true);
    pass.setDepthCompareOperation(gpu.CompareFunction.less);
    pass.setColorBlendEnable(true);
    pass.setColorBlendEquation(gpu.ColorBlendEquation(colorBlendOperation: gpu.BlendOperation.add, sourceColorBlendFactor: gpu.BlendFactor.one, destinationColorBlendFactor: gpu.BlendFactor.oneMinusSourceAlpha, alphaBlendOperation: gpu.BlendOperation.add, sourceAlphaBlendFactor: gpu.BlendFactor.one, destinationAlphaBlendFactor: gpu.BlendFactor.oneMinusSourceAlpha));
    final transients = gpu.gpuContext.createHostBuffer();
    final vertices = transients.emplace(float32(<double>[-1,-1,-1,0,0,1,0,0,1,1,-1,-1,1,0,0,1,0,1,1,1,-1,1,1,0,0,1,1,-1,1,-1,0,1,0,0,0,1,-1,-1,1,0,0,0,1,1,1,1,-1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,-1,1,1,0,1,1,1,1,1]));
    final indices = transients.emplace(uint16(<int>[0,1,3,3,1,2,1,5,2,2,5,6,5,4,6,6,4,7,4,0,7,7,0,3,3,2,7,7,2,6,4,5,0,0,5,1]));
    final mvp = transients.emplace(float32Mat(vec.Matrix4(0.5,0,0,0,0,0.5,0,0,0,0,0.2,0,0,0,0.5,1) * vec.Matrix4.rotationX(time) * vec.Matrix4.rotationY(time * seedX) * vec.Matrix4.rotationZ(time * seedY) * vec.Matrix4.diagonal3(vec.Vector3(scale, scale, scale))));
    pass.bindVertexBuffer(vertices, 8);
    pass.bindIndexBuffer(indices, gpu.IndexType.int16, 36);
    final frameInfoSlot = vertex.getUniformSlot('FrameInfo');
    pass.bindUniform(frameInfoSlot, mvp);
    final sampledTexture = gpu.gpuContext.createTexture(gpu.StorageMode.hostVisible, 5, 5, enableShaderReadUsage: true);
    sampledTexture!.overwrite(uint32(<int>[0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF,0x00000000,0xFFFFFFFF]));
    final texSlot = pipeline.fragmentShader.getUniformSlot('tex');
    pass.bindTexture(texSlot, sampledTexture);
    pass.draw();
    commandBuffer.submit();
    final image = renderTexture.asImage();
    canvas.drawImage(image, Offset(-renderTexture.width / 2, 0), Paint());
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

class TextureCubePage extends StatefulWidget {
  const TextureCubePage({super.key});
  @override
  State<TextureCubePage> createState() => _TextureCubePageState();
}

class _TextureCubePageState extends State<TextureCubePage> {
  Ticker? tick;
  double time = 0, seedX = -0.512511498387847167, seedY = 0.521295573094847167, scale = 1.0, depthClearValue = 1.0;

  @override
  void initState() {
    super.initState();
    tick = Ticker((elapsed) => setState(() => time = elapsed.inMilliseconds / 1000.0));
    tick!.start();
  }

  @override
  void dispose() {
    tick?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(children: <Widget>[
      Slider(value: seedX, max: 1, min: -1, onChanged: (value) => {setState(() => seedX = value)}),
      Slider(value: seedY, max: 1, min: -1, onChanged: (value) => {setState(() => seedY = value)}),
      Slider(value: scale, max: 3, min: 0.1, onChanged: (value) => {setState(() => scale = value)}),
      Slider(value: depthClearValue, max: 1, min: 0, onChanged: (value) => {setState(() => depthClearValue = value)}),
      CustomPaint(painter: TextureCubePainter(time, seedX, seedY, scale, depthClearValue)),
    ]);
  }
}

// --------------------------------------------------
// Source: .\lib\triangle.dart
// --------------------------------------------------
class TrianglePainter extends CustomPainter {
  TrianglePainter(this.time, this.seedX, this.seedY);
  double time, seedX, seedY;

  @override
  void paint(Canvas canvas, Size size) {
    final gpu.Texture? renderTexture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate, 300, 300, enableRenderTargetUsage: true, enableShaderReadUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (renderTexture == null) return;
    final gpu.Texture? depthTexture = gpu.gpuContext.createTexture(gpu.StorageMode.deviceTransient, 300, 300, format: gpu.gpuContext.defaultDepthStencilFormat, enableRenderTargetUsage: true, coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (depthTexture == null) return;
    final commandBuffer = gpu.gpuContext.createCommandBuffer();
    final renderTarget = gpu.RenderTarget.singleColor(gpu.ColorAttachment(texture: renderTexture), depthStencilAttachment: gpu.DepthStencilAttachment(texture: depthTexture));
    final pass = commandBuffer.createRenderPass(renderTarget);
    final vertex = shaderLibrary['UnlitVertex']!;
    final fragment = shaderLibrary['UnlitFragment']!;
    final pipeline = gpu.gpuContext.createRenderPipeline(vertex, fragment);
    pass.bindPipeline(pipeline);
    pass.setColorBlendEnable(true);
    pass.setColorBlendEquation(gpu.ColorBlendEquation(colorBlendOperation: gpu.BlendOperation.add, sourceColorBlendFactor: gpu.BlendFactor.one, destinationColorBlendFactor: gpu.BlendFactor.oneMinusSourceAlpha, alphaBlendOperation: gpu.BlendOperation.add, sourceAlphaBlendFactor: gpu.BlendFactor.one, destinationAlphaBlendFactor: gpu.BlendFactor.oneMinusSourceAlpha));
    final transients = gpu.gpuContext.createHostBuffer();
    final vertices = transients.emplace(float32(<double>[-0.5,-0.5,0,0.5,0.5,-0.5]));
    pass.bindVertexBuffer(vertices, 3);
    final mvp = vec.Matrix4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0.5,1) * vec.Matrix4.rotationX(time) * vec.Matrix4.rotationY(time * seedX) * vec.Matrix4.rotationZ(time * seedY);
    final color = <double>[0, 1, 0, 1];
    final frameInfoSlot = vertex.getUniformSlot('FrameInfo');
    final frameInfoFloats = Float32List.fromList([...mvp.storage, ...color]);
    final frameInfoView = transients.emplace(frameInfoFloats.buffer.asByteData());
    pass.bindUniform(frameInfoSlot, frameInfoView);
    pass.draw();
    commandBuffer.submit();
    final image = renderTexture.asImage();
    canvas.drawImage(image, Offset(-renderTexture.width / 2, 0), Paint());
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

class TrianglePage extends StatefulWidget {
  const TrianglePage({super.key});
  @override
  State<TrianglePage> createState() => _TrianglePageState();
}

class _TrianglePageState extends State<TrianglePage> {
  Ticker? tick;
  double time = 0, seedX = -0.512511498387847167, seedY = 0.521295573094847167;

  @override
  void initState() {
    super.initState();
    tick = Ticker((elapsed) => setState(() => time = elapsed.inMilliseconds / 1000.0));
    tick!.start();
  }

  @override
  void dispose() {
    tick?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(children: <Widget>[
      Slider(value: seedX, max: 1, min: -1, onChanged: (value) => {setState(() => seedX = value)}),
      Slider(value: seedY, max: 1, min: -1, onChanged: (value) => {setState(() => seedY = value)}),
      CustomPaint(painter: TrianglePainter(time, seedX, seedY)),
    ]);
  }
}

/*// COMBINED FILE - GENERATED BY df_combinator v0.1.0
// DO NOT EDIT THIS FILE DIRECTLY. It is an amalgamation of multiple source files.
// Generated on: 2025-07-20 00:07:47.569362Z UTC

// --- Consolidated Imports ---
import 'dart:math';
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter_gpu/gpu.dart' as gpu;
import 'package:flutter_gpu_shaders/build.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:gputest/colors.dart';
import 'package:gputest/julia.dart';
import 'package:gputest/main.dart';
import 'package:gputest/texture_cube.dart';
import 'package:gputest/triangle.dart';
import 'package:native_assets_cli/native_assets_cli.dart';
import 'package:vector_math/vector_math_64.dart';
// --- End of Imports ---

// --------------------------------------------------
// Source: .\hook\build.dart
// --------------------------------------------------
// import 'package:native_assets_cli/native_assets_cli.dart';
// import 'package:flutter_gpu_shaders/build.dart';

// void main(List<String> args) async {
//   await build(args, (config, output) async {
//     await buildShaderBundleJson(
//         /*buildConfig*/ buildInput: config,
//         buildOutput: output,
//         manifestFileName: 'shaders/TestLibrary.shaderbundle.json');
//   });
// }

// --------------------------------------------------
// Source: .\lib\colors.dart
// --------------------------------------------------
// import 'dart:typed_data';

// import 'package:flutter/material.dart';
// import 'package:flutter/scheduler.dart';

// import 'package:flutter_gpu/gpu.dart' as gpu;

// import 'shaders.dart';

ByteData float32(List<double> values) {
  return Float32List.fromList(values).buffer.asByteData();
}

ByteData float32Mat(Matrix4 matrix) {
  return Float32List.fromList(matrix.storage).buffer.asByteData();
}


class ColorsPainter extends CustomPainter {
  ColorsPainter(this.red, this.green, this.blue);

  double red;
  double green;
  double blue;

  @override
  void paint(Canvas canvas, Size size) {
    /// Allocate a new renderable texture.
    final gpu.Texture? texture =
        gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate, 300, 300);

    final vertex = shaderLibrary['ColorsVertex']!;
    final fragment = shaderLibrary['ColorsFragment']!;
    final pipeline = gpu.gpuContext.createRenderPipeline(vertex, fragment);

    final gpu.DeviceBuffer? vertexBuffer = gpu.gpuContext
        .createDeviceBuffer(gpu.StorageMode.hostVisible, 4 * 6 * 3);
    vertexBuffer!.overwrite(Float32List.fromList(<double>[
      -0.5, -0.5,  1.0*red, 0.0, 0.0, 1.0, //
       0,    0.5,  0.0, 1.0*green, 0.0, 1.0, //
       0.5, -0.5,  0.0, 0.0, 1.0*blue, 1.0, //
    ]).buffer.asByteData());

    final commandBuffer = gpu.gpuContext.createCommandBuffer();

    final renderTarget = gpu.RenderTarget.singleColor(
      gpu.ColorAttachment(texture: texture!),
    );
    final pass = commandBuffer.createRenderPass(renderTarget);

    pass.bindPipeline(pipeline);
    pass.bindVertexBuffer(
        gpu.BufferView(vertexBuffer,
            offsetInBytes: 0, lengthInBytes: vertexBuffer.sizeInBytes), 3);
    pass.draw();

    commandBuffer.submit();

    /// Wrap the Flutter GPU texture as a ui.Image and draw it like normal!
    final image = texture.asImage();

    canvas.drawImage(image, Offset(-texture.width / 2, 0), Paint());
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return true;
  }
}

class ColorsPage extends StatefulWidget {
  const ColorsPage({super.key});

  @override
  State<ColorsPage> createState() => _ColorsPageState();
}

class _ColorsPageState extends State<ColorsPage> {
  Ticker? tick;
  double time = 0;
  double deltaSeconds = 0;
  double red = 1.0;
  double green = 1.0;
  double blue = 1.0;

  @override
  void initState() {
    tick = Ticker(
      (elapsed) {
        setState(() {
          double previousTime = time;
          time = elapsed.inMilliseconds / 1000.0;
          deltaSeconds = previousTime > 0 ? time - previousTime : 0;
        });
      },
    );
    tick!.start();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        Slider(
            value: red,
            max: 1,
            min: 0,
            onChanged: (value) => {setState(() => red = value)}),
        Slider(
            value: green,
            max: 1,
            min: 0,
            onChanged: (value) => {setState(() => green = value)}),
        Slider(
            value: blue,
            max: 1,
            min: 0,
            onChanged: (value) => {setState(() => blue = value)}),
        CustomPaint(
          painter: ColorsPainter(red, green, blue),
        ),
      ],
    );
  }
}

// --------------------------------------------------
// Source: .\lib\julia.dart
// --------------------------------------------------
// import 'dart:typed_data';

// import 'package:flutter/material.dart';
// import 'package:flutter/scheduler.dart';
// import 'dart:ui' as ui;

// import 'package:flutter_gpu/gpu.dart' as gpu;

class JuliaSetPainter extends CustomPainter {
  JuliaSetPainter(this.time, this.seedX, this.seedY);

  double time;
  double seedX;
  double seedY;
  final maxIterations = 100;
  final escapeDistance = 10;

  @override
  void paint(Canvas canvas, Size size) {
    final gpu.Texture? texture =
        gpu.gpuContext.createTexture(gpu.StorageMode.hostVisible, 21, 9);  // keep width odd
    if (texture == null) {
      return;
    }

    // Illustrating creating a texture and using that to create image
    // The are arbitrary methods of filling buffer and transferring it to the texture
    // so that it changes via time and the sliders.  
    if(seedX>0.0) {
      // flashing CHECKER BOARD of any size (works as long as width is odd)
      texture.overwrite(Uint32List.fromList(
        
        List<int>.generate(texture.width*texture.height, (int index) {
            int onColor = seedY<0 ? (0xFF*seedY).toInt() | 0x00FFFF00 :
                          (0xFF*-seedY).toInt()<<8 | 0x00FF00FF;
            return index.isEven ?  (time.toInt().isEven ? onColor : 0xFF000000) : (time.toInt().isEven ? 0xFF000000 :onColor);
        }, growable: false) ).buffer.asByteData());
      //(oldway) fixed 3x3 checkerboard
      //texture.overwrite(Uint32List.fromList(<int>[
      //  0xFFFFFFFF, 0xFF000000, 0xFFFFFFFF, //
      //  0xFF000000, 0xFFFFFFFF, 0xFF000000, //
      //  0xFFFFFFFF, 0xFF000000, 0xFFFFFFFF, //
      //]).buffer.asByteData());
    } else {
      var buffer = Int32List(texture.width * texture.height);
      for (int i = 0; i < buffer.length; i++) {
        int xi = i % texture.width;
        int yi = i ~/ texture.width;
        double x = (xi.toDouble() - texture.width / 2) / (texture.width * 0.75);
        double y = (yi.toDouble() - texture.height / 2) / (texture.height * 0.75);
        int iterations = 0;
        for (int it = 0; it < maxIterations; it++) {
          // Square the complex number and add the seed offset.
          double newX = x * x - y * y + seedX;
          y = 2 * x * y + seedY;
          x = newX;
          if (x * x + y * y > escapeDistance * escapeDistance) {
            iterations = it;
            break;
          }
        }
        int shade = (iterations / maxIterations * 0xFF).toInt();
        buffer[i] = Color.fromARGB(0xFF, (shade*time).toInt(), (seedX*time).toInt(), (seedY*time).toInt()).value;
      }

      texture.overwrite(buffer.buffer.asByteData());
    }

    final ui.Image image = texture.asImage();

    canvas.scale(50);
    canvas.drawImage(image, Offset(-texture.width / 2, 0), Paint());
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return true;
  }
}

class JuliaSetPage extends StatefulWidget {
  const JuliaSetPage({super.key});

  @override
  State<JuliaSetPage> createState() => _JuliaSetPageState();
}

class _JuliaSetPageState extends State<JuliaSetPage> {
  Ticker? tick;
  double time = 0;
  double deltaSeconds = 0;
  double seedX = -0.512511498387847167;
  double seedY = 0.521295573094847167;

  @override
  void initState() {
    tick = Ticker(
      (elapsed) {
        setState(() {
          double previousTime = time;
          time = elapsed.inMilliseconds / 1000.0;
          deltaSeconds = previousTime > 0 ? time - previousTime : 0;
        });
      },
    );
    tick!.start();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        Slider(
            value: seedX,
            max: 1,
            min: -1,
            onChanged: (value) => {setState(() => seedX = value)}),
        Slider(
            value: seedY,
            max: 1,
            min: -1,
            onChanged: (value) => {setState(() => seedY = value)}),
        CustomPaint(
          painter: JuliaSetPainter(time, seedX, seedY),
        ),
      ],
    );
  }
}

// --------------------------------------------------
// Source: .\lib\main.dart
// --------------------------------------------------
// import 'dart:math';

// import 'package:flutter/material.dart';
// import 'package:gputest/colors.dart';
// import 'package:gputest/julia.dart';
// import 'package:gputest/texture_cube.dart';
// import 'package:gputest/triangle.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
        useMaterial3: true,
      ),
      home: const DemoPage(),
    );
  }
}

class DemoPage extends StatefulWidget {
  const DemoPage({super.key});

  @override
  State<DemoPage> createState() => _DemoPageState();
}

class _DemoPageState extends State<DemoPage> {
  int widgetIndex = 0;

  @override
  Widget build(BuildContext context) {
    final widgets = [
      const ColorsPage(),
      const TextureCubePage(),
      const TrianglePage(),
      const JuliaSetPage()
    ];
    final widgetsNames = <String>[
      'ColorsPage() - vert/uniform example',
      'TextureCubePage() - vert/indices/uniform/texture/depth example',
      'TrianglePage() - vert/uniform example',
      'JuliaSetPage() - Texture example'
    ];
    return Scaffold(
      appBar: AppBar(
        title: Row(
          children: [
            AnimatedOpacity(
              opacity: widgetIndex > 0 ? 1 : 0,
              duration: const Duration(milliseconds: 300),
              child: IconButton(
                onPressed: () => setState(() {
                  widgetIndex = max(0, widgetIndex - 1);
                }),
                icon: const Icon(Icons.arrow_back_ios),
              ),
            ),
            Expanded(
                child: Text(
              'GPU demo ${widgetsNames[widgetIndex]}',
              textAlign: TextAlign.center,
            )),
            AnimatedOpacity(
              opacity: widgetIndex < widgets.length - 1 ? 1 : 0,
              duration: const Duration(milliseconds: 300),
              child: IconButton(
                onPressed: () => setState(() {
                  widgetIndex = min(widgets.length - 1, widgetIndex + 1);
                }),
                icon: const Icon(Icons.arrow_forward_ios),
              ),
            ),
          ],
        ),
      ),
      extendBodyBehindAppBar: false,
      body: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Expanded(child: widgets[widgetIndex]
              //child: IndexedStack(
              //  index: widgetIndex,
              //  children: widgets,
              //),
              ),
        ],
      ),
    );
  }
}

// --------------------------------------------------
// Source: .\lib\shaders.dart
// --------------------------------------------------
// import 'package:flutter_gpu/gpu.dart' as gpu;

const String _kShaderBundlePath =
    'build/shaderbundles/TestLibrary.shaderbundle';
// NOTE: If you're building a library, the path must be prefixed
//       with a package name. For example:
//      'packages/my_cool_renderer/build/shaderbundles/my_renderer.shaderbundle'

gpu.ShaderLibrary? _shaderLibrary;
gpu.ShaderLibrary get shaderLibrary {
  if (_shaderLibrary != null) {
    return _shaderLibrary!;
  }
  _shaderLibrary = gpu.ShaderLibrary.fromAsset(_kShaderBundlePath);
  if (_shaderLibrary != null) {
    return _shaderLibrary!;
  }

  throw Exception("Failed to load shader bundle! ($_kShaderBundlePath)");
}

// --------------------------------------------------
// Source: .\lib\texture_cube.dart
// --------------------------------------------------
// import 'dart:typed_data';

// import 'package:flutter/material.dart';
// import 'package:flutter/scheduler.dart';
// import 'package:vector_math/vector_math_64.dart';

// import 'package:flutter_gpu/gpu.dart' as gpu;

// import 'shaders.dart';

ByteData float32(List<double> values) {
  return Float32List.fromList(values).buffer.asByteData();
}

ByteData uint16(List<int> values) {
  return Uint16List.fromList(values).buffer.asByteData();
}

ByteData uint32(List<int> values) {
  return Uint32List.fromList(values).buffer.asByteData();
}

ByteData float32Mat(Matrix4 matrix) {
  return Float32List.fromList(matrix.storage).buffer.asByteData();
}

class TextureCubePainter extends CustomPainter {
  TextureCubePainter(this.time, this.seedX, this.seedY,this.scale,this.depthClearValue);

  double time;
  double seedX;
  double seedY;
  double scale;
  double depthClearValue;

  @override
  void paint(Canvas canvas, Size size) {
    /// Allocate a new renderable texture.
    final gpu.Texture? renderTexture = gpu.gpuContext.createTexture(
        gpu.StorageMode.devicePrivate, 300, 300,
        enableRenderTargetUsage: true,
        enableShaderReadUsage: true,
        coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (renderTexture == null) {
      return;
    }

    final gpu.Texture? depthTexture = gpu.gpuContext.createTexture(
        gpu.StorageMode.deviceTransient, 300, 300,
        format: gpu.gpuContext.defaultDepthStencilFormat,
        enableRenderTargetUsage: true,
        coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (depthTexture == null) {
      return;
    }

    /// Create the command buffer. This will be used to submit all encoded
    /// commands at the end.
    final commandBuffer = gpu.gpuContext.createCommandBuffer();

    /// Define a render target. This is just a collection of attachments that a
    /// RenderPass will write to.
    final renderTarget = gpu.RenderTarget.singleColor(
      gpu.ColorAttachment(texture: renderTexture),
      depthStencilAttachment: gpu.DepthStencilAttachment(
          texture: depthTexture, depthClearValue: depthClearValue),
    );

    /// Add a render pass encoder to the command buffer so that we can start
    /// encoding commands.
    final pass = commandBuffer.createRenderPass(renderTarget);

    /// Create a RenderPipeline using shaders from the asset.
    final vertex = shaderLibrary['TextureVertex']!;
    final fragment = shaderLibrary['TextureFragment']!;
    final pipeline = gpu.gpuContext.createRenderPipeline(vertex, fragment);

    pass.bindPipeline(pipeline);

    pass.setDepthWriteEnable(true);
    pass.setDepthCompareOperation(gpu.CompareFunction.less);

    /// (Optional) Configure blending for the first color attachment.
    pass.setColorBlendEnable(true);
    pass.setColorBlendEquation(gpu.ColorBlendEquation(
        colorBlendOperation: gpu.BlendOperation.add,
        sourceColorBlendFactor: gpu.BlendFactor.one,
        destinationColorBlendFactor: gpu.BlendFactor.oneMinusSourceAlpha,
        alphaBlendOperation: gpu.BlendOperation.add,
        sourceAlphaBlendFactor: gpu.BlendFactor.one,
        destinationAlphaBlendFactor: gpu.BlendFactor.oneMinusSourceAlpha));

    /// Append quick geometry and uniforms to a host buffer that will be
    /// automatically uploaded to the GPU later on.
    final transients = gpu.gpuContext.createHostBuffer();
    final vertices = transients.emplace(float32(<double>[
      -1, -1, -1, /* */ 0, 0, /* */ 1, 0, 0, 1, //
      1, -1, -1, /*  */ 1, 0, /* */ 0, 1, 0, 1, //
      1, 1, -1, /*   */ 1, 1, /* */ 0, 0, 1, 1, //
      -1, 1, -1, /*  */ 0, 1, /* */ 0, 0, 0, 1, //
      -1, -1, 1, /*  */ 0, 0, /* */ 0, 1, 1, 1, //
      1, -1, 1, /*   */ 1, 0, /* */ 1, 0, 1, 1, //
      1, 1, 1, /*    */ 1, 1, /* */ 1, 1, 0, 1, //
      -1, 1, 1, /*   */ 0, 1, /* */ 1, 1, 1, 1, //
    ]));
    final indices = transients.emplace(uint16(<int>[
      0, 1, 3, 3, 1, 2, //
      1, 5, 2, 2, 5, 6, //
      5, 4, 6, 6, 4, 7, //
      4, 0, 7, 7, 0, 3, //
      3, 2, 7, 7, 2, 6, //
      4, 5, 0, 0, 5, 1, //
    ]));
    final mvp = transients.emplace(float32Mat(Matrix4(
          0.5, 0, 0, 0, //
          0, 0.5, 0, 0, //
          0, 0, 0.2, 0, //
          0, 0, 0.5, 1, //
        ) *
        Matrix4.rotationX(time) *
        Matrix4.rotationY(time * seedX) *
        Matrix4.rotationZ(time * seedY) *
        Matrix4.diagonal3( Vector3(scale,scale,scale))
      ));   
    /// Bind the vertex and index buffer.
    pass.bindVertexBuffer(vertices, 8);
    pass.bindIndexBuffer(indices, gpu.IndexType.int16, 36);

    /// Bind the host buffer data we just created to the vertex shader's uniform
    /// slots. Although the locations are specified in the shader and are
    /// predictable, we can optionally fetch the uniform slots by name for
    /// convenience.
    final frameInfoSlot = vertex.getUniformSlot('FrameInfo');
    pass.bindUniform(frameInfoSlot, mvp);

    final sampledTexture = gpu.gpuContext.createTexture(
        gpu.StorageMode.hostVisible, 5, 5,
        enableShaderReadUsage: true);
    sampledTexture!.overwrite(uint32(<int>[
      0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, //
      0x00000000, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0x00000000, //
      0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, //
      0x00000000, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0x00000000, //
      0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, 0x00000000, 0xFFFFFFFF, //
    ]));

    final texSlot = pipeline.fragmentShader.getUniformSlot('tex');
    pass.bindTexture(texSlot, sampledTexture);

    /// And finally, we append a draw call.
    pass.draw();

    /// Submit all of the previously encoded passes. Passes are encoded in the
    /// same order they were created in.
    commandBuffer.submit();

    /// Wrap the Flutter GPU texture as a ui.Image and draw it like normal!
    final image = renderTexture.asImage();

    canvas.drawImage(image, Offset(-renderTexture.width / 2, 0), Paint());
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return true;
  }
}

class TextureCubePage extends StatefulWidget {
  const TextureCubePage({super.key});

  @override
  State<TextureCubePage> createState() => _TextureCubePageState();
}

class _TextureCubePageState extends State<TextureCubePage> {
  Ticker? tick;
  double time = 0;
  double deltaSeconds = 0;
  double seedX = -0.512511498387847167;
  double seedY = 0.521295573094847167;
  double scale = 1.0;
  double depthClearValue = 1.0;

  @override
  void initState() {
    tick = Ticker(
      (elapsed) {
        setState(() {
          double previousTime = time;
          time = elapsed.inMilliseconds / 1000.0;
          deltaSeconds = previousTime > 0 ? time - previousTime : 0;
        });
      },
    );
    tick!.start();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        Slider(
            value: seedX,
            max: 1,
            min: -1,
            onChanged: (value) => {setState(() => seedX = value)}),
        Slider(
            value: seedY,
            max: 1,
            min: -1,
            onChanged: (value) => {setState(() => seedY = value)}),
        Slider(
            value: scale,
            max: 3,
            min: 0.1,
            onChanged: (value) => {setState(() => scale = value)}),
        Slider(
            value: depthClearValue,
            max: 1,
            min: 0,
            onChanged: (value) => {setState(() => depthClearValue = value)}),
        CustomPaint(
          painter: TextureCubePainter(time, seedX, seedY, scale, depthClearValue),
        ),
      ],
    );
  }
}

// --------------------------------------------------
// Source: .\lib\triangle.dart
// --------------------------------------------------
// import 'dart:typed_data';

// import 'package:flutter/material.dart';
// import 'package:flutter/scheduler.dart';

// import 'package:flutter_gpu/gpu.dart' as gpu;

// import 'shaders.dart';

ByteData float32(List<double> values) {
  return Float32List.fromList(values).buffer.asByteData();
}

ByteData float32Mat(Matrix4 matrix) {
  return Float32List.fromList(matrix.storage).buffer.asByteData();
}

class TrianglePainter extends CustomPainter {
  TrianglePainter(this.time, this.seedX, this.seedY);

  double time;
  double seedX;
  double seedY;

  @override
  void paint(Canvas canvas, Size size) {
    /// Allocate a new renderable texture.
    final gpu.Texture? renderTexture = gpu.gpuContext.createTexture(
        gpu.StorageMode.devicePrivate, 300, 300,
        enableRenderTargetUsage: true,
        enableShaderReadUsage: true,
        coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (renderTexture == null) {
      return;
    }

    final gpu.Texture? depthTexture = gpu.gpuContext.createTexture(
        gpu.StorageMode.deviceTransient, 300, 300,
        format: gpu.gpuContext.defaultDepthStencilFormat,
        enableRenderTargetUsage: true,
        coordinateSystem: gpu.TextureCoordinateSystem.renderToTexture);
    if (depthTexture == null) {
      return;
    }

    /// Create the command buffer. This will be used to submit all encoded
    /// commands at the end.
    final commandBuffer = gpu.gpuContext.createCommandBuffer();

    /// Define a render target. This is just a collection of attachments that a
    /// RenderPass will write to.
    final renderTarget = gpu.RenderTarget.singleColor(
      gpu.ColorAttachment(texture: renderTexture),
      depthStencilAttachment: gpu.DepthStencilAttachment(texture: depthTexture),
    );

    /// Add a render pass encoder to the command buffer so that we can start
    /// encoding commands.
    final pass = commandBuffer.createRenderPass(renderTarget);

    /// Create a RenderPipeline using shaders from the asset.
    final vertex = shaderLibrary['UnlitVertex']!;
    final fragment = shaderLibrary['UnlitFragment']!;
    final pipeline = gpu.gpuContext.createRenderPipeline(vertex, fragment);

    pass.bindPipeline(pipeline);

    /// (Optional) Configure blending for the first color attachment.
    pass.setColorBlendEnable(true);
    pass.setColorBlendEquation(gpu.ColorBlendEquation(
        colorBlendOperation: gpu.BlendOperation.add,
        sourceColorBlendFactor: gpu.BlendFactor.one,
        destinationColorBlendFactor: gpu.BlendFactor.oneMinusSourceAlpha,
        alphaBlendOperation: gpu.BlendOperation.add,
        sourceAlphaBlendFactor: gpu.BlendFactor.one,
        destinationAlphaBlendFactor: gpu.BlendFactor.oneMinusSourceAlpha));

    /// Append quick geometry and uniforms to a host buffer that will be
    /// automatically uploaded to the GPU later on.
    final transients = gpu.gpuContext.createHostBuffer();
    final vertices = transients.emplace(float32(<double>[
      -0.5, -0.5, //
      0, 0.5, //
      0.5, -0.5, //
    ]));
    

    /// Bind the vertex data. In this case, we won't bother binding an index
    /// buffer.
    pass.bindVertexBuffer(vertices, 3);

    /* PreVulkanSupport - no longer possible because Vulkan has poor Uniform support
    and we can only do a single blob...
    final color = transients.emplace(float32(<double>[0, 1, 0, 1])); // rgba
    final mvp = transients.emplace(float32Mat(Matrix4(
          1, 0, 0, 0, //
          0, 1, 0, 0, //
          0, 0, 1, 0, //
          0, 0, 0.5, 1, //
        ) *
        Matrix4.rotationX(time) *
        Matrix4.rotationY(time * seedX) *
        Matrix4.rotationZ(time * seedY)));

    /// Bind the host buffer data we just created to the vertex shader's uniform
    /// slots. Although the locations are specified in the shader and are
    /// predictable, we can optionally fetch the uniform slots by name for
    /// convenience.
    final mvpSlot = pipeline.vertexShader.getUniformSlot('mvp')!;
    final colorSlot = pipeline.vertexShader.getUniformSlot('color')!;
    pass.bindUniform(mvpSlot, mvp);
    pass.bindUniform(colorSlot, color);
    PreVulkanSupport */

    final mvp = Matrix4(
          1, 0, 0, 0, //
          0, 1, 0, 0, //
          0, 0, 1, 0, //
          0, 0, 0.5, 1, //
        ) *
        Matrix4.rotationX(time) *
        Matrix4.rotationY(time * seedX) *
        Matrix4.rotationZ(time * seedY);
    final color = <double>[0, 1, 0, 1]; // rgba
    // We must manually map the members of the 'FrameInfo' uniform struct with the
    // corresponding float data
    final frameInfoSlot = vertex.getUniformSlot('FrameInfo');
    final frameInfoFloats = Float32List.fromList([
      mvp.storage[0],
      mvp.storage[1],
      mvp.storage[2],
      mvp.storage[3],
      mvp.storage[4],
      mvp.storage[5],
      mvp.storage[6],
      mvp.storage[7],
      mvp.storage[8],
      mvp.storage[9],
      mvp.storage[10],
      mvp.storage[11],
      mvp.storage[12],
      mvp.storage[13],
      mvp.storage[14],
      mvp.storage[15],
      color[0], // r 
      color[1], // g
      color[2], // b
      color[3], // a
    ]);
    final frameInfoView =
        transients.emplace(frameInfoFloats.buffer.asByteData());
    pass.bindUniform(frameInfoSlot, frameInfoView);

    /// And finally, we append a draw call.
    pass.draw();

    /// Submit all of the previously encoded passes. Passes are encoded in the
    /// same order they were created in.
    commandBuffer.submit();

    /// Wrap the Flutter GPU texture as a ui.Image and draw it like normal!
    final image = renderTexture.asImage();

    canvas.drawImage(image, Offset(-renderTexture.width / 2, 0), Paint());
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return true;
  }
}

class TrianglePage extends StatefulWidget {
  const TrianglePage({super.key});

  @override
  State<TrianglePage> createState() => _TrianglePageState();
}

class _TrianglePageState extends State<TrianglePage> {
  Ticker? tick;
  double time = 0;
  double deltaSeconds = 0;
  double seedX = -0.512511498387847167;
  double seedY = 0.521295573094847167;

  @override
  void initState() {
    tick = Ticker(
      (elapsed) {
        setState(() {
          double previousTime = time;
          time = elapsed.inMilliseconds / 1000.0;
          deltaSeconds = previousTime > 0 ? time - previousTime : 0;
        });
      },
    );
    tick!.start();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        Slider(
            value: seedX,
            max: 1,
            min: -1,
            onChanged: (value) => {setState(() => seedX = value)}),
        Slider(
            value: seedY,
            max: 1,
            min: -1,
            onChanged: (value) => {setState(() => seedY = value)}),
        CustomPaint(
          painter: TrianglePainter(time, seedX, seedY),
        ),
      ],
    );
  }
}

// --------------------------------------------------
// Source: .\test\widget_test.dart
// --------------------------------------------------
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

// import 'package:flutter/material.dart';
// import 'package:flutter_test/flutter_test.dart';

// import 'package:gputest/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}*/
